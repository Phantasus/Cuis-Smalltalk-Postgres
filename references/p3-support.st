Object subclass: #P3ArrayValueParser	instanceVariableNames: 'stream converter'	classVariableNames: ''	package: 'P3-Support'!!P3ArrayValueParser commentStamp: '' prior: 0!I am P3ArrayValueParser, I parse the external text representation of an array value.Curly braces and commas are used for the structure, double quotes for strings and backslashes for escaping.  {{1,2},{3,4}}  {"NULL","\\","\"","\{","\}",NULL,ONE,TWO}See https://www.postgresql.org/docs/9.4/arrays.html#ARRAYS-IOWe do minimal error checking / error handling since this is a representation generated by the PostgreSQL server that is always correct.!!P3ArrayValueParser methodsFor: 'instance creation'!on: readStream	"Initialize me on the textual readStream given"		stream := readStream! !!P3ArrayValueParser methodsFor: 'instance creation'!converter: block	"Set my converter to block, which will parse the text of array elements"		converter := block! !!P3ArrayValueParser methodsFor: 'accessing'!next	"Parse and return the next array value"	| char str |	self consumeWhitespace.	(char := stream peek) = ${		ifTrue: [ ^ self parseArray ].	char = $"		ifTrue: [ str := self parseString ]		ifFalse: [ (str := self parseElement) = 'NULL' ifTrue: [ ^ nil ] ].	^ self convertElement: str! !!P3ArrayValueParser methodsFor: 'private-parsing'!parseArray	stream next. "Consume opening curly brace"	^ Array streamContents: [ :array | 		[ stream atEnd or: [ stream peekFor: $} ] ] whileFalse: [ 			array nextPut: self next.			self consumeWhitespace.			stream peekFor: $, ] ]! !!P3ArrayValueParser methodsFor: 'private-parsing'!consumeWhitespace	"Strip whitespaces from the input stream."	[ stream atEnd not and: [ stream peek isSeparator ] ] whileTrue: [ 		stream next ]! !!P3ArrayValueParser methodsFor: 'private-parsing'!parseElement	^ String streamContents: [ :string | 		[ stream atEnd or: [ ',}' includes: stream peek ] ] whileFalse: [ 			string nextPut: stream next ] ]! !!P3ArrayValueParser methodsFor: 'private-parsing'!convertElement: string	^ converter 		ifNil: [ string ]		ifNotNil: [ converter value: string ]! !!P3ArrayValueParser methodsFor: 'private-parsing'!parseString	stream next. "Consume opening double quote"	^ String streamContents: [ :string | 		[ stream atEnd or: [ stream peekFor: $" ] ] whileFalse: [ | char |			(char := stream next) = $\ ifTrue: [ char := stream next ].			string nextPut: char ] ]! !Object subclass: #P3Converter	instanceVariableNames: 'encoder timezone map stringWriteStream asciiReadStream asciiWriteStream'	classVariableNames: ''	package: 'P3-Support'!!P3Converter commentStamp: '' prior: 0!I am P3Converter.I convert field values to objects, taking into account their type.I known the character encoding and timezone of the current database connection.!!P3Converter methodsFor: 'converting-geometric'!convertBoxFrom: bytes length: length description: description	^ P3Box readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-geometric'!convertCircleFrom: bytes length: length description: description	^ P3Circle readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-geometric'!convertLineFrom: bytes length: length description: description	^ P3Line readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-geometric'!convertPointFrom: bytes length: length description: description	^ P3Point readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-geometric'!convertLineSegmentFrom: bytes length: length description: description	^ P3LineSegment readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-geometric'!convertPathFrom: bytes length: length description: description	^ P3Path readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-geometric'!convertPolygonFrom: bytes length: length description: description	^ P3Polygon readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'input/output'!asciiCStringFrom: binaryStream	| byte |	asciiWriteStream reset.	[ (byte := binaryStream next) = 0 ]		whileFalse: [ asciiWriteStream nextPut: byte asCharacter ].	^ asciiWriteStream contents! !!P3Converter methodsFor: 'input/output'!encodedCStringFrom: binaryStream	stringWriteStream reset.	[ binaryStream peekFor: 0 ]		whileFalse: [ stringWriteStream nextPut: (encoder nextFromStream: binaryStream) ].	^ stringWriteStream contents! !!P3Converter methodsFor: 'accessing'!timezone	^ timezone! !!P3Converter methodsFor: 'accessing'!encoder: anObject	encoder := anObject! !!P3Converter methodsFor: 'accessing'!encoder	^ encoder ifNil: [ encoder := ZnCharacterEncoder utf8 ]! !!P3Converter methodsFor: 'accessing'!mapOid: anOoid type: aTypename to: aBlockOrSymbol	^ map at: anOoid put: { aTypename . aBlockOrSymbol }	! !!P3Converter methodsFor: 'accessing'!timezone: anObject	timezone := anObject! !!P3Converter methodsFor: 'converting-arrays'!convertFloatArrayFrom: bytes length: length description: description	| input |	input := ZnLimitedReadStream on: bytes limit: length.	input := ZnCharacterReadStream on: input encoding: self encoder. 	^ P3ArrayValueParser new 		on: input;		converter: [ :string | Float readFrom: string ];		next! !!P3Converter methodsFor: 'converting-arrays'!convertStringArrayFrom: bytes length: length description: description	| input |	input := ZnLimitedReadStream on: bytes limit: length.	input := ZnCharacterReadStream on: input encoding: self encoder. 	^ P3ArrayValueParser new 		on: input;		next! !!P3Converter methodsFor: 'converting-arrays'!convertBooleanArrayFrom: bytes length: length description: description	| input |	input := ZnLimitedReadStream on: bytes limit: length.	input := ZnCharacterReadStream on: input encoding: self encoder. 	^ P3ArrayValueParser new 		on: input;		converter: [ :string | string first = $t ];		next! !!P3Converter methodsFor: 'converting-arrays'!convertIntegerArrayFrom: bytes length: length description: description	| input |	input := ZnLimitedReadStream on: bytes limit: length.	input := ZnCharacterReadStream on: input encoding: self encoder. 	^ P3ArrayValueParser new 		on: input;		converter: [ :string | Integer readFrom: string base: 10 ];		next! !!P3Converter methodsFor: 'converting-special'!convertJsonFrom: bytes length: length description: description	| input |	input := ZnLimitedReadStream on: bytes limit: length.	input := ZnCharacterReadStream on: input encoding: self encoder. 	^ (NeoJSONReader on: input)			mapClass: NeoJSONObject;			propertyNamesAsSymbols: true;			next! !!P3Converter methodsFor: 'converting-special'!convertUuidFrom: bytes length: length description: description		^ UUID nilUUID readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(.	stream print: self encoder identifier.	stream space.	self timezone ifNotNil: [ :tmz | stream print: tmz id ].	stream nextPut: $)! !!P3Converter methodsFor: 'converting-chronology'!convertTimeWithTimezoneFrom: bytes length: length description: description	"TIME WITH TIME ZONE corresponds to Time plus an offset. 	Time does not hold a time zone nor an offset.	We comnpare the offset coming in with the offset for that time today 	in our connection's timezone, if they differ we correct to compensate"	| stream time offset connectionOffset translatedTime |	stream := self asciiStreamFor: bytes length: length.	time := Time readFrom: stream.	offset := DateAndTime readTimezoneOffsetFrom: stream default: Duration zero.	connectionOffset := self timezone offsetForTimestamp: (ZTimestamp today + time).	^ offset = connectionOffset 		ifTrue: [ time ]		ifFalse: [ 			translatedTime := time subtractTime: (offset - connectionOffset).			^ translatedTime seconds < 0 				ifTrue: [ translatedTime addSeconds: 24 * 60 * 60 ]				ifFalse: [ translatedTime ] ]! !!P3Converter methodsFor: 'converting-chronology'!convertTimeFrom: bytes length: length description: description	"TIME [ WITHOUT TIME ZONE ] corresponds to Time, i.e. 	both have no knowledge about the applicable time zone.	We assume the time to be correct as there is no sensible conversion to be done"		^ Time readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-chronology'!convertDateAndTimeWithoutTimezoneFrom: bytes length: length description: description	"TIMESTAMP WITHOUT TIME ZONE (TIMESTAMP) is stored internally in Postgres the way it was inserted, its representation remains constant, with no offset added. We use the timezone of the connection to do the necessary shifting. This assumes that the timezones used during insert/update and query are the same."	| timestamp offset |	timestamp := DateAndTime readFrom: (self asciiStreamFor: bytes length: length) defaultOffset: Duration zero.	offset := self timezone offsetForTimestamp: timestamp.	^ timestamp translateTo: offset! !!P3Converter methodsFor: 'converting-chronology'!convertIntervalFrom: bytes length: length description: description	^ P3Interval readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-chronology'!convertDateFrom: bytes length: length description: description	^ Date readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting-chronology'!convertDateAndTimeFrom: bytes length: length description: description	"TIMESTAMP WITH TIME ZONE (TIMESTAMPTZ) is stored internally in Postgres as UTC, but represented in the timezone of the connection, with a correct offset added. In other words, Postgres does the necessary shifting, we just have to read the result"		^ DateAndTime readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'private'!asciiStreamFor: bytes length: length	| asciiString |	asciiString := asciiReadStream originalContents.	asciiString size < length		ifTrue: [ 			asciiReadStream := (asciiString := String new: ((length // 64) + 1) * 64) readStream ].	bytes next: length into: asciiString. "implicit cheap ASCII conversion"	asciiReadStream setFrom: 1 to: length.	^ asciiReadStream ! !!P3Converter methodsFor: 'initialize'!initializeTypeMap	map := self class typeMap! !!P3Converter methodsFor: 'initialize'!initialize	super initialize.	asciiReadStream := String new readStream.	asciiWriteStream := String new writeStream.	stringWriteStream := String new writeStream.	self initializeTypeMap! !!P3Converter methodsFor: 'initialize'!initializeFrom: properties	| serverTimezone serverEncoder |	"Try to resolve the session/connection timezone"	serverTimezone := properties at: 'TimeZone' ifAbsent: [ 'GMT' ].	"The fallback for unknown timezones is normally GMT but can be overwritten with ZCurrentTimezone."	serverTimezone := [ ZTimezone id: serverTimezone ] on: Error do: [ ZCurrentTimezone value ].	self timezone: serverTimezone.	"Try to resolve the session/connection character encoder/decoder"	serverEncoder := properties at: 'client_encoding' ifAbsent: [ 'UTF8' ].	"The fallback for unknown encodings is normally UTF8 but can be overwritten ZnDefaultCharacterEncoder."	serverEncoder := ZnCharacterEncoder newForEncoding: serverEncoder.	self encoder: serverEncoder! !!P3Converter methodsFor: 'converting'!convertByteArrayFrom: bytes length: length description: description	| size byteArray digitValues |	self assert: (bytes next: 2) = #[92 120]. "\x"	size := (length - 2) // 2.	digitValues := #(-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 1 2 3 4 5 6 7 8 9 -1 -1 -1 -1 -1 -1 -1 10 11 12 13 14 15 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 10 11 12 13 14 15 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1).	byteArray := ByteArray new: size.	1 to: size do: [ :index | | value |		value := digitValues at: bytes next + 1.		value := (value bitShift: 4) + (digitValues at: bytes next + 1).		byteArray at: index put: value ].	^ byteArray ! !!P3Converter methodsFor: 'converting'!convertIntegerFrom: bytes length: length description: description	^ Integer readFrom: (self asciiStreamFor: bytes length: length) base: 10! !!P3Converter methodsFor: 'converting'!convertBitStringFrom: bytes length: length description: description	^ P3BitString readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting'!convert: bytes length: length description: description	^ map 		at: description typeOid 		ifPresent: [ :type | | lambda |			lambda := type second.	 		lambda isSymbol 				ifTrue: [ self perform: lambda with: bytes with: length with: description ]				ifFalse: [ lambda value: bytes value: length value: description ] ]		ifAbsent: [ (P3Error cannotConvertTypeOid: description typeOid) signal ]! !!P3Converter methodsFor: 'converting'!convertStringFrom: bytes length: length description: description	| endPosition |	length = 0 ifTrue: [ ^ '' ].	endPosition := bytes position + length.	stringWriteStream reset.	[ stringWriteStream nextPut: (encoder nextFromStream: bytes) ]			doWhileTrue: [ bytes position < endPosition ].	^ stringWriteStream contents! !!P3Converter methodsFor: 'converting'!convertFixedBitStringFrom: bytes length: length description: description	^ P3FixedBitString readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting'!convertFloatFrom: bytes length: length description: description	^ Float readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting'!convertBooleanFrom: bytes length: length description: description	self assert: length = 1.	^ bytes next = $t charCode! !!P3Converter methodsFor: 'converting'!convertScaledDecimalFrom: bytes length: length description: description	^ ScaledDecimal readFrom: (self asciiStreamFor: bytes length: length)! !!P3Converter methodsFor: 'converting'!convertSymbolFrom: bytes length: length description: description	^ (self convertStringFrom: bytes length: length description: description) asSymbol! !!P3Converter methodsFor: 'converting'!convertVoidFrom: bytes length: length description: description	self assert: length = 0.	^ nil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Converter class	instanceVariableNames: ''!!P3Converter class methodsFor: 'accessing'!supportedTypes	"Return the list of PostgreSQL internal type names that we can convert to objects."		^ self typeMap values collect: #first! !!P3Converter class methodsFor: 'accessing'!typeMap	^ IdentityDictionary newFromPairs: #(			16 #(bool #convertBooleanFrom:length:description:) 			17 #(bytea #convertByteArrayFrom:length:description:) 			19 #(name #convertStringFrom:length:description:) 			20 #(int8 #convertIntegerFrom:length:description:) 			21 #(int2 #convertIntegerFrom:length:description:) 			23 #(int4 #convertIntegerFrom:length:description:) 			25 #(text #convertStringFrom:length:description:) 			26 #(oid #convertIntegerFrom:length:description:) 			700 #(float4 #convertFloatFrom:length:description:) 			701 #(float8 #convertFloatFrom:length:description:) 			1042 #(bpchar #convertStringFrom:length:description:) 			1043 #(varchar #convertStringFrom:length:description:)			1560 #(bit #convertFixedBitStringFrom:length:description:)			1562 #(varbit #convertBitStringFrom:length:description:)			1700 #(numeric #convertScaledDecimalFrom:length:description:) 			2278 #(void #convertVoidFrom:length:description:)			"chronology"			1082 #(date #convertDateFrom:length:description:) 			1083 #(time #convertTimeFrom:length:description:) 			1114 #(timestamp #convertDateAndTimeWithoutTimezoneFrom:length:description:) 			1184 #(timestamptz #convertDateAndTimeFrom:length:description:)			1186 #(interval #convertIntervalFrom:length:description:)			1266 #(timetz #convertTimeWithTimezoneFrom:length:description:)			"special"			114 #(json #convertJsonFrom:length:description:)			2950 #(uuid #convertUuidFrom:length:description:)			3802 #(jsonb #convertJsonFrom:length:description:)			"arrays"			1000 #(#'_bool' #convertBooleanArrayFrom:length:description:)			1007 #(#'_int4' #convertIntegerArrayFrom:length:description:)			1009 #(#'_text' #convertStringArrayFrom:length:description:)			1015 #(#'_varchar' #convertStringArrayFrom:length:description:)			1022 #(#'_float8' #convertFloatArrayFrom:length:description:)			"geometric"			600 #(point #convertPointFrom:length:description:)			601 #(lseg #convertLineSegmentFrom:length:description:)			602 #(path #convertPathFrom:length:description:)			603 #(box #convertBoxFrom:length:description:)			604 #(polygon #convertPolygonFrom:length:description:)			628 #(line #convertLineFrom:length:description:)			718 #(circle #convertCircleFrom:length:description:)		)! !Object subclass: #P3MessageBuffer	instanceVariableNames: 'tag payload size'	classVariableNames: ''	package: 'P3-Support'!!P3MessageBuffer commentStamp: '' prior: 0!I am P3MessageBuffer.I am a reusable buffer to hold a single protocol message read.I try to prevent allocations as much as possible.I grow as needed.!!P3MessageBuffer methodsFor: 'accessing'!size	^ size! !!P3MessageBuffer methodsFor: 'accessing'!readStream	^ payload! !!P3MessageBuffer methodsFor: 'accessing'!rawByteBuffer	^ payload originalContents! !!P3MessageBuffer methodsFor: 'accessing'!capacity	^ self rawByteBuffer size! !!P3MessageBuffer methodsFor: 'accessing'!payloadCopy	^ self rawByteBuffer copyFrom: 1 to: size! !!P3MessageBuffer methodsFor: 'accessing'!tag	^ tag! !!P3MessageBuffer methodsFor: 'initialization'!initializeForSize: actualSize	(payload isNil or: [ actualSize > self capacity ])		ifTrue: [ payload := (ByteArray new: ((actualSize // 1024) + 1) * 1024) readStream ].	size := actualSize.	payload setFrom: 1 to: size! !!P3MessageBuffer methodsFor: 'initialization'!initialize	super initialize.	self initializeForSize: 0! !!P3MessageBuffer methodsFor: 'initialization'!readFrom: readStream	| length |	self tag: readStream next asCharacter.	length := (self uint32From: readStream) - 4.	self initializeForSize: length.	length > 0		ifTrue: [ readStream next: self size into: self rawByteBuffer ]! !!P3MessageBuffer methodsFor: 'initialization'!tag: character	tag := character! !!P3MessageBuffer methodsFor: 'reading'!uint32From: stream	| uint32 |	uint32 := stream next.	uint32 := (uint32 bitShift: 8) + stream next.	uint32 := (uint32 bitShift: 8) + stream next.	uint32 := (uint32 bitShift: 8) + stream next.	^ uint32! !Object subclass: #P3MessageBuilder	instanceVariableNames: 'encoder byteStream'	classVariableNames: ''	package: 'P3-Support'!!P3MessageBuilder commentStamp: '' prior: 0!I am P3MessageBuilder.I am a helper class used to construct binary messages.!!P3MessageBuilder methodsFor: 'initialization'!initWithEncoder: anEncoder	byteStream := WriteStream on: (ByteArray new: 200).	encoder := anEncoder! !!P3MessageBuilder methodsFor: 'converting'!asBytes	^ byteStream contents! !!P3MessageBuilder methodsFor: 'writing'!nextPutInt16: anInteger	2 to: 1 by: -1 do: [ :index | byteStream nextPut: (anInteger digitAt: index) ]! !!P3MessageBuilder methodsFor: 'writing'!writeTo: aConnection tag: aChar	aConnection nextPut: aChar asInteger.! !!P3MessageBuilder methodsFor: 'writing'!nextPutParameterAsText: aValue description: paramDescription	| sizePosition endPosition |		sizePosition := byteStream position.	byteStream nextPutAll: #[ 0 0 0 0 ]. "placeholder"	aValue p3PrintUsing: self on: (ZnCharacterWriteStream on: byteStream encoding: encoder).	endPosition := byteStream position.	"Go back and set the correct size"	byteStream position: sizePosition.	byteStream uint32: (endPosition - sizePosition - 4).	byteStream position: endPosition! !!P3MessageBuilder methodsFor: 'writing'!nextPutInt32: anInteger	4 to: 1 by: -1 do: [ :index | byteStream nextPut: (anInteger digitAt: index) ]! !!P3MessageBuilder methodsFor: 'writing'!nextPutNullParameter	"Write a NULL Parameter"	byteStream nextPutAll: #[255 255 255 255]! !!P3MessageBuilder methodsFor: 'writing'!nextPutByte: anInteger	byteStream nextPut: anInteger! !!P3MessageBuilder methodsFor: 'writing'!nextPutString: aString	aString do: [ :each | encoder nextPut: each toStream: byteStream ].	byteStream nextPut: 0! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printDateAndTime: dateAndTime on: stream	"Use ISO 8601 YYYY-MM-DDThh:mm:ss.s+ZZ:zz"		stream nextPut: $'.	dateAndTime printOn: stream.	stream nextPut: $' ! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printScaledDecimal: scaledDecimal on: stream	"For ScaledDecimals, use a regular floating point like representation"		scaledDecimal 		printOn: stream 		showingDecimalPlaces: scaledDecimal scale! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printGeometricObject: geometricObject on: stream	"Delegate to P3GeometricObject that knows how to print itself in unescaped, raw PSQL text format"		geometricObject printOn: stream! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printTime: time on: stream	"Use ISO 8601 hh:mm:ss"		stream nextPut: $'.	time print24: true on: stream.	stream nextPut: $'! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printBitString: bitString on: stream	"Delegate to P3[Fixed]BitString that knows how to print itself in unescaped, raw PSQL text format"		bitString printOn: stream! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printObject: object on: stream	"In general, just use the standard print string representation"		object printOn: stream ! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printInterval: interval on: stream	"Delegate to P3Interval that knows how to print itself in postgresql style"		stream print: interval! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printValuesArray: valuesArray on: stream	| first |	first := true.	stream nextPut: ${.	valuesArray do: [ :each |		first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $, ].		each p3PrintUsing: self on: stream ].	stream nextPut: $}! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printString: string on: stream	"For strings just output the characters of the string, no escaping is needed"		stream nextPutAll: string! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printNullOn: stream	"This cannot happen since nil is already handled earlier,	see P3PreparedStatement>>#bindStrings:"		self shouldNotImplement ! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printDate: date on: stream	"Use ISO 8601 YYYY-MM-DD"		stream nextPut: $'.	date printOn: stream format: #(3 2 1 $- 1 1 2).	stream nextPut: $'! !!P3MessageBuilder methodsFor: 'printing-dispatched'!printByteArray: byteArray on: stream	"Use the bytea Hex Format for bytes (ByteArray), as in \xDEADBEEF"		| hex |	stream nextPutAll: '\x'.	hex := '0123456789ABCDEF'.	byteArray do: [ :byte | 		stream 			nextPut: (hex at: (byte bitShift: -4) + 1);			nextPut: (hex at: (byte bitAnd: 15) + 1) ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3MessageBuilder class	instanceVariableNames: ''!!P3MessageBuilder class methodsFor: 'instance creation'!newWithEncoder: anEncoder	^ self new initWithEncoder: anEncoder! !Object subclass: #P3ParameterDescription	instanceVariableNames: 'typeOid'	classVariableNames: ''	package: 'P3-Support'!!P3ParameterDescription commentStamp: '' prior: 0!I am P3ParameterDescription.I am used to support the extended query protocol.In particular, after the prepare/parse phase, my instances describe the type of each binding parameter.!!P3ParameterDescription methodsFor: 'accessing'!typeOid	^ typeOid! !!P3ParameterDescription methodsFor: 'accessing'!typeName	^ (P3Converter typeMap at: self typeOid ifAbsent: [ ^ self typeOid ]) first! !!P3ParameterDescription methodsFor: 'accessing'!typeOid: anObject	typeOid := anObject! !!P3ParameterDescription methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(.	stream << self typeName.	stream nextPut: $)! !Object subclass: #P3RowFieldDescription	instanceVariableNames: 'fieldName tableOid attributeNumber typeOid typeSize typeModifier format'	classVariableNames: ''	package: 'P3-Support'!!P3RowFieldDescription commentStamp: '' prior: 0!I am P3RowFieldDescriptionI hold meta data regarding the result of an SQL query. I describe one field/column in the result.I know how to interpret and convert raw bytes with the help of a P3Converter (see #convert:length:using:) into objects.!!P3RowFieldDescription methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(.	stream << fieldName.	stream space.	stream << self typeName.	stream nextPut: $)! !!P3RowFieldDescription methodsFor: 'accessing'!typeModifier	^ typeModifier! !!P3RowFieldDescription methodsFor: 'accessing'!typeSize: anObject	typeSize := anObject! !!P3RowFieldDescription methodsFor: 'accessing'!tableOid	^ tableOid! !!P3RowFieldDescription methodsFor: 'accessing'!typeOid: anObject	typeOid := anObject! !!P3RowFieldDescription methodsFor: 'accessing'!tableOid: anObject	tableOid := anObject! !!P3RowFieldDescription methodsFor: 'accessing'!fieldName: anObject	fieldName := anObject! !!P3RowFieldDescription methodsFor: 'accessing'!typeModifier: anObject	typeModifier := anObject! !!P3RowFieldDescription methodsFor: 'accessing'!attributeNumber: anObject	attributeNumber := anObject! !!P3RowFieldDescription methodsFor: 'accessing'!attributeNumber	^ attributeNumber! !!P3RowFieldDescription methodsFor: 'accessing'!typeName	^ (P3Converter typeMap at: self typeOid ifAbsent: [ ^ self typeOid ]) first! !!P3RowFieldDescription methodsFor: 'accessing'!typeOid	^ typeOid! !!P3RowFieldDescription methodsFor: 'accessing'!format: anObject	format := anObject! !!P3RowFieldDescription methodsFor: 'accessing'!fieldName	^ fieldName! !!P3RowFieldDescription methodsFor: 'accessing'!format	^ format! !!P3RowFieldDescription methodsFor: 'accessing'!typeSize	^ typeSize! !!P3RowFieldDescription methodsFor: 'converting'!convert: bytes length: length using: converter	^ converter convert: bytes length: length description: self! !