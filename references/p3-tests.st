TestCase subclass: #P3ArrayValueParserTest	instanceVariableNames: ''	classVariableNames: ''	package: 'P3-Tests'!!P3ArrayValueParserTest commentStamp: '' prior: 0!P3ArrayValueParserTest holds unit tests for P3ArrayValueParser.!!P3ArrayValueParserTest methodsFor: 'tests'!testSpecial	self 		assert: (P3ArrayValueParser new 			on: '{{one,two},{"\"","\\"},{NULL,""},{"NULL",1}' readStream;			next)		equals: #( ('one' 'two') ('"' '\') (nil '') ('NULL' '1') )! !!P3ArrayValueParserTest methodsFor: 'tests'!testPlain	self 		assert: (P3ArrayValueParser new 			on: '{{one,two},{three,four},{NULL,""}' readStream;			next)		equals: #( ('one' 'two') ('three' 'four') (nil '') )! !!P3ArrayValueParserTest methodsFor: 'tests'!testIntegers	self 		assert: (P3ArrayValueParser new 			on: '{{1,2},{3,4},{0,-1}}' readStream;			converter: [ :string | string asInteger ];			next)		equals: #( (1 2) (3 4) (0 -1) )! !TestCase subclass: #P3ClientTest	instanceVariableNames: 'client'	classVariableNames: 'Url'	package: 'P3-Tests'!!P3ClientTest commentStamp: '' prior: 0!P3ClientTest holds unit tests for the P3 PSQL client.Configure by setting my class side's connection URL.  P3ClientTest url: 'psql://sven:secret@localhost:5432/database'.The minimal being the following:  P3ClientTest url: 'psql://sven@localhost'.Benchmarks  P3ClientTest new setupBenchmark1.  P3ClientTest new runBenchmark1.  P3ClientTest new runBenchmark1Bench.  P3ClientTest new runAllTests.!!P3ClientTest methodsFor: 'benchmarking'!benchmark1Size	^ 10000! !!P3ClientTest methodsFor: 'benchmarking'!runBenchmark1Bench	| result timeToRun |	result := nil.	self setUp.	timeToRun := [ result := client query: 'SELECT * FROM benchmark1' ] benchFor: 5 seconds.	self assert: result numberOfRecords equals: self benchmark1Size.	self tearDown.	^ timeToRun ! !!P3ClientTest methodsFor: 'benchmarking'!runAllTests	"Runs all tests on the same connection/session"		| testSelectors timeToRun |	testSelectors := self class selectors select: [ :each | 'test*' match: each ].	self setUp.	timeToRun := [ testSelectors do: [ :each | self perform: each ] ] timeToRun.	self tearDown.	^ timeToRun ! !!P3ClientTest methodsFor: 'benchmarking'!runBenchmark1	| result timeToRun |	result := nil.	self setUp.	timeToRun := [ result := client query: 'SELECT * FROM benchmark1' ] timeToRun.	self assert: result numberOfRecords equals: self benchmark1Size.	self tearDown.	^ timeToRun ! !!P3ClientTest methodsFor: 'benchmarking'!setupBenchmark1	| timeToRun |	self setUp. 	timeToRun := [		client query: 'DROP TABLE IF EXISTS benchmark1'.		client query: 'CREATE TABLE benchmark1 (n_int INTEGER, n_float FLOAT, hex TEXT, roman TEXT, words TEXT)'.		1 to: self benchmark1Size do: [ :n |			| sql |			sql := 'INSERT INTO benchmark1 (n_int, n_float, hex, roman, words) VALUES ({1}, {2}, ''{3}'', ''{4}'', ''{5}'')' 				format: { n. Float pi * n. n printStringHex. n printStringRoman.  n asWords }.			client query: sql ] ] timeToRun.	self tearDown.	^ timeToRun  ! !!P3ClientTest methodsFor: 'testing'!isServerVersionAtLeastMajor: major minor: minor	| serverVersion |	serverVersion := ($. split: client serverVersion) collect: #asNumber.	^ serverVersion first > major		or:			[ serverVersion first = major and: [ serverVersion second >= minor ] ]! !!P3ClientTest methodsFor: 'tests'!testJsonConversion	| data result |		(self isServerVersionAtLeastMajor: 9 minor: 5) ifFalse: [ ^ self skip ].	data := NeoJSONObject new 		x: 1; 		str: 'les élève Français'; 		foo: 'tab' , Character tab asString; 		bar: #(true nil -123); 		yourself.	result := client query: ('SELECT ''{1}''::json' format: { data printString }).	self assert: result firstFieldOfFirstRecord equals: data.	result := client query: ('SELECT ''{1}''::jsonb' format: { data printString }).	self assert: result firstFieldOfFirstRecord equals: data! !!P3ClientTest methodsFor: 'tests'!testNotification	| raised |	raised := false.	[ client query: 'SET client_min_messages TO notice; DROP TABLE IF EXISTS abcdef' ] 		on: P3Notification 		do: [ :notification | 			raised := true.			self 				assert: (notification description includesSubstring: 'abcdef')				description: ('{1} does not contain abcdef' format: {notification description}).			notification resume ].	self assert: raised description: 'no notification triggered'! !!P3ClientTest methodsFor: 'tests'!testLineSegmentConversion	| result |	result := client query: 'SELECT lseg ''(1,2),(3,4)'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3LineSegment start: (P3Point x: 1 y: 2) stop: (P3Point x: 3 y: 4)).	result := client query: 'SELECT lseg ''(0,0),(1,0)'''.	self 		assert: result firstFieldOfFirstRecord 		equals: P3LineSegment xAxisUnit.	result := client query: 'SELECT lseg ''(0,0),(0,1)'''.	self 		assert: result firstFieldOfFirstRecord 		equals: P3LineSegment yAxisUnit ! !!P3ClientTest methodsFor: 'tests'!testByteArrayConversion	| result bytes |		client execute: 'DROP TABLE IF EXISTS testBytea'.	client execute: 'CREATE TABLE testBytea (id int, bytes bytea)'.		bytes := #[ 0 1 2 3 4 254 255 ].		client execute: ('INSERT INTO testBytea (id, bytes) VALUES (100, ''{1}'')' format: { '\x', bytes hex }).	"Read the bytes back as a hex string"	result := client query: 'SELECT encode(bytes, ''hex'') FROM testBytea WHERE id = 100'.	self assert: result firstRecord first asLowercase equals: bytes hex asLowercase.	"Read the bytes back as binary data"		result := client query: 'SELECT bytes FROM testBytea WHERE id = 100'.	self assert: result firstRecord first equals: bytes.	client execute: 'DROP TABLE testBytea'! !!P3ClientTest methodsFor: 'tests'!testMultiStatement	| result |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.	result := client query: 'INSERT INTO table1 (id, name, enabled) VALUES (1, ''foo'', true); INSERT INTO table1 (id, name, enabled) VALUES (2, ''bar'', false)'.	self assert: result results equals: #('INSERT 0 1' 'INSERT 0 1').	self deny: result hasDescriptions.	self deny: result hasData.	result := client query: 'SELECT * from table1'.	self assert: result firstResult equals: 'SELECT 2'.	self assert: result firstRowCount equals: 2.	self assert: result data equals: #((1 'foo' true)(2 'bar' false)).	client execute: 'DROP TABLE table1'! !!P3ClientTest methodsFor: 'tests'!testLineConversion	| result |	(self isServerVersionAtLeastMajor: 9 minor: 4) ifFalse: [ ^ self skip ].	result := client query: 'SELECT line''{1,2,3}'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Line a: 1 b: 2 c: 3).	result := client query: 'SELECT line''{0,1,0}'''.	self 		assert: result firstFieldOfFirstRecord 		equals: P3Line xAxis.	result := client query: 'SELECT line''{1,0,0}'''.	self 		assert: result firstFieldOfFirstRecord 		equals: P3Line yAxis.! !!P3ClientTest methodsFor: 'tests'!testSimpleTable	| result |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.	client execute: 'INSERT INTO table1 (id, name, enabled) VALUES (1, ''foo'', true)'.	client execute: 'INSERT INTO table1 (id, name, enabled) VALUES (2, ''bar'', false)'.	client execute: 'INSERT INTO table1 (id, name, enabled) VALUES (NULL, NULL, NULL)'.	result := client query: 'SELECT id, name, enabled FROM table1 WHERE id = 1'.	self assert: result firstRecord equals: #(1 'foo' true).	result := client query: 'SELECT id, name, enabled FROM table1 WHERE id = 2'.	self assert: result firstRecord equals: #(2 'bar' false).	result := client query: 'SELECT id, name, enabled FROM table1 WHERE id IS NULL'.	self assert: result firstRecord equals: #(nil nil nil).	client execute: 'DELETE FROM table1 WHERE id IS NULL'.	client execute: 'UPDATE table1 SET name = ''xxx'' WHERE id = 2'.	result := client query: 'SELECT id, name, enabled FROM table1 WHERE id = 2'.	self assert: result firstRecord equals: #(2 'xxx' false).	client execute: 'DROP TABLE table1'! !!P3ClientTest methodsFor: 'tests'!testSqlFunction	| x y result |	client execute: 'DROP FUNCTION IF EXISTS my_add(x INTEGER, y INTEGER)'.	client execute: 'CREATE FUNCTION my_add(x INTEGER, y INTEGER) RETURNS INTEGER AS $$ SELECT x + y $$ LANGUAGE SQL'.	x := 99 atRandom.	y := 99 atRandom.	result := client query: ('SELECT my_add({1},{2}) AS answer' format: { x. y }).	self assert: result firstFieldOfFirstRecord equals: x + y.	client execute: 'DROP FUNCTION my_add(x INTEGER, y INTEGER)'.! !!P3ClientTest methodsFor: 'tests'!testUuid	| result uuid num |		client execute: 'DROP TABLE IF EXISTS testUUID'.	client execute: 'CREATE TABLE testUUID (id UUID, num INTEGER)'.		uuid := UUID new.	num := 1234 atRandom.		client execute: ('INSERT INTO testUUID (id, num) VALUES (''{1}'', {2})' format: { uuid. num }).	result := client query: ('SELECT * FROM testUUID WHERE id = ''{1}''' format: {uuid}).		self assert: result firstRecord equals: { uuid. num }.		client execute: 'DROP TABLE testUUID'! !!P3ClientTest methodsFor: 'tests'!testStringEscaping	| result string |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, string VARCHAR)'.	string := 'An SQL string with a single quote '' and a double quote ".'.	"We can use #printString as Pharo strings are similar to SQL string"	client execute: ('INSERT INTO table1 (id, string) VALUES ({1}, {2})' format: { 1. string printString }).	result := client query: 'SELECT id, string FROM table1 WHERE id = 1'.	self assert: result firstRecord equals: { 1. string }.	client execute: 'DROP TABLE table1'! !!P3ClientTest methodsFor: 'tests'!testBitStringConversion	| result |	result := client query: 'SELECT B''11001111'''.	self assert: result firstFieldOfFirstRecord equals: (P3FixedBitString bits: 2r11110011).	result := client query: 'SELECT B''11001111''::bit varying'.	self assert: result firstFieldOfFirstRecord equals: (P3BitString bits: 2r11110011).! !!P3ClientTest methodsFor: 'tests'!testBooleanConversion	| result |	result := client query: 'SELECT b::boolean FROM (VALUES (true), (false), (NULL)) t(b)'.	self assert: result data equals: #((true) (false) (nil))! !!P3ClientTest methodsFor: 'tests'!testTimezone	| result originalTimezone |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL PRIMARY KEY, name TEXT, t1 TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP, t2 TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP)'.	originalTimezone := client converter timezone id.	client execute: ('INSERT INTO table1 (name) VALUES (''{1}'')' format: { originalTimezone }).	result := client query: 'SELECT id, name, t1, t2 FROM table1 WHERE id = 1'.	self assert: result firstRecord first equals: 1.	self assert: result firstRecord second equals: client converter timezone id.	self assert: (DateAndTime now - result firstRecord third) abs < 30 seconds.	self assert: (DateAndTime now - result firstRecord fourth) abs < 30 seconds.	client execute: 'SET TIMEZONE TO ''GMT'''.	result := client query: 'SHOW TIMEZONE'.	self assert: result firstFieldOfFirstRecord equals: 'GMT'.	client converter timezone: (ZTimezone gmt).	client execute: ('INSERT INTO table1 (name) VALUES (''{1}'')' format: { client converter timezone id }).	result := client query: 'SELECT id, name, t1, t2 FROM table1 WHERE id = 1'.	self assert: result firstRecord first equals: 1.	"t1 is now off, since postgres did not adjust it"	self assert: (DateAndTime now asUTC - result firstRecord fourth) abs < 30 seconds.	result := client query: 'SELECT id, name, t1, t2 FROM table1 WHERE id = 2'.	self assert: result firstRecord first equals: 2.	self assert: result firstRecord second equals: client converter timezone id.	self assert: (DateAndTime now asUTC - result firstRecord third) abs < 30 seconds.	self assert: (DateAndTime now asUTC - result firstRecord fourth) abs < 30 seconds.	client execute: ('SET TIMEZONE TO ''{1}''' format: { originalTimezone }).	client converter timezone: (ZTimezone id: originalTimezone).	client execute: 'DROP TABLE table1'! !!P3ClientTest methodsFor: 'tests'!testBoxConversion	| result |	result := client query: 'SELECT box ''(3,4),(1,2)'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Box upperRight: (P3Point x: 3 y: 4) lowerLeft: (P3Point x: 1 y: 2)).	result := client query: 'SELECT box ''(0,0),(0,0)'''.	self 		assert: result firstFieldOfFirstRecord 		equals: P3Box zero.	result := client query: 'SELECT box ''(1,1),(0,0)'''.	self 		assert: result firstFieldOfFirstRecord 		equals: P3Box unit! !!P3ClientTest methodsFor: 'tests'!testPolygonConversion	| result |	result := client query: 'SELECT polygon ''((1,2),(3,4),(5,6))'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Polygon points: { P3Point x: 1 y: 2. P3Point x: 3 y: 4. P3Point x: 5 y: 6 })! !!P3ClientTest methodsFor: 'tests'!testSession	| session |		session := client session. "from #setUp"		self assert: client session isNotNil.		client execute: 'SELECT NOW();'.		self assert: session equals: client session.		client close.		self assert: client session isNil.		client connect.		self deny: session = client session.		client clearSession.		self 		deny: client isConnected;		assert: client session isNil.						! !!P3ClientTest methodsFor: 'tests'!testNonAsciiStrings	| result |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, string VARCHAR)'.	client execute: 'INSERT INTO table1 (id, string) VALUES (1, ''Les élèves Français'')'.	result := client query: 'SELECT id, string FROM table1 WHERE id = 1'.	self assert: result firstRecord equals: #(1 'Les élèves Français').	client execute: ('INSERT INTO table1 (id, string) VALUES (2, ''100 {1}'')' format: { Character euro }).	result := client query: 'SELECT id, string FROM table1 WHERE id = 2'.	self assert: result firstRecord equals: {2. '100 {1}' format: { Character euro }}.	client execute: 'DROP TABLE table1'! !!P3ClientTest methodsFor: 'tests'!testArrayTypes	| result |	client execute: 'DROP TABLE IF EXISTS table_a'.	client execute: 'CREATE TABLE table_a (id INTEGER, name TEXT, text_a TEXT[], int_a INTEGER[])'.	client execute: 'INSERT INTO table_a (id, name, text_a, int_a) VALUES (1, ''foo'', ARRAY[''foo'',''bar''], ARRAY[1,2])'.	client execute: 'INSERT INTO table_a (id, name, text_a, int_a) VALUES (2, ''null'', ''{"NULL",NULL}'', ''{0,NULL}'')'.	client execute: 'INSERT INTO table_a (id, name, text_a, int_a) VALUES (3, ''zero'', ''{}'', ''{}'')'.	client execute: 'INSERT INTO table_a (id, name, text_a, int_a) VALUES (4, ''escape'', ARRAY[''a"b'',''c\d''], ''{1,2}'')'.	result := client query: 'SELECT id, name, text_a, int_a FROM table_a WHERE id = 1'.	self assert: result firstRecord equals: #(1 'foo' #('foo' 'bar') #(1 2)).	result := client query: 'SELECT id, name, text_a, int_a FROM table_a WHERE id = 2'.	self assert: result firstRecord equals: #(2 'null' #('NULL' nil) #(0 nil)).	result := client query: 'SELECT id, name, text_a, int_a FROM table_a WHERE id = 3'.	self assert: result firstRecord equals: #(3 'zero' #() #()).	result := client query: 'SELECT id, name, text_a, int_a FROM table_a WHERE id = 4'.	self assert: result firstRecord equals: #(4 'escape' #('a"b' 'c\d') #(1 2)).	client execute: 'DROP TABLE table_a'! !!P3ClientTest methodsFor: 'tests'!testChronology	| result |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL PRIMARY KEY, name TEXT, timestamp_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP, date_created DATE DEFAULT CURRENT_DATE, time_created TIME DEFAULT CURRENT_TIME)'.	client execute: 'INSERT INTO table1 (name) VALUES (''Chronology'')'.	result := client query: 'SELECT id, name, timestamp_created, date_created, time_created FROM table1 WHERE id = 1'.	self assert: result firstRecord first equals: 1.	self assert: result firstRecord second equals: 'Chronology'.	self assert: (DateAndTime now - result firstRecord third) abs < 30 seconds.	self assert: (Date today - result firstRecord fourth) abs < 30 seconds.	self assert: (Time now asSeconds - result firstRecord fifth asSeconds) abs < 30.	client execute: ('INSERT INTO table1 (name, timestamp_created, date_created, time_created) VALUES (''{1}'', ''{2}'', ''{3}'', ''{4}'')'		format: { 'Pharo'. DateAndTime now. Date today. Time now }).	result := client query: 'SELECT id, name, timestamp_created, date_created, time_created FROM table1 WHERE id = 2'.	self assert: result firstRecord first equals: 2.	self assert: result firstRecord second equals: 'Pharo'.	self assert: (DateAndTime now - result firstRecord third) abs < 30 seconds.	self assert: (Date today - result firstRecord fourth) abs < 30 seconds.	self assert: (Time now asSeconds - result firstRecord fifth asSeconds) abs < 30.	client execute: 'DROP TABLE table1'! !!P3ClientTest methodsFor: 'tests'!testIntervalConversion	| result |	result := client query: 'SELECT INTERVAL ''1 years 1 mons 1 days 1 hours 1 minutes 1 seconds'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Interval years: 1 months: 1 days: 1 hours: 1 minutes: 1 seconds: 1).	result := client query: 'SELECT INTERVAL ''0 seconds'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Interval zero).	result := client query: 'SELECT INTERVAL ''1 years 2 mons 3 days 0 hours 0 minutes 0 seconds'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Interval years: 1 months: 2 days: 3 hours: 0 minutes: 0 seconds: 0).	result := client query: 'SELECT INTERVAL ''1 hours 2 minutes 3 seconds'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Interval years: 0 months: 0 days: 0 hours: 1 minutes: 2 seconds: 3).	result := client query: 'SELECT INTERVAL ''1 years 1 mons 1 days 1 hours 1 minutes 1 seconds ago'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Interval years: -1 months: -1 days: -1 hours: -1 minutes: 1 seconds: 1).! !!P3ClientTest methodsFor: 'tests'!testTimeConversion	| result offset formattedOffset |	"TIME WITHOUT TIME ZONE maps 1 on 1"	result := client query: 'SELECT TIME ''01:02:03'''.	self assert: result firstFieldOfFirstRecord equals: (Time hour: 1 minute: 2 second: 3).	"Figure out the offset of the connection's time zone"	offset := client converter timezone offsetForTimestamp: ZTimestamp today.	formattedOffset := String streamContents: [ :out |		out nextPut: (offset positive ifTrue: [ $+ ] ifFalse: [ $- ]).		offset hours printOn: out base: 10 length: 2 padded: true.		out nextPut: $:.		offset minutes printOn: out base: 10 length: 2 padded: true ].	"TIME WITH TIME ZONE does not change when the time zone matches"	result := client query: 'SELECT TIMETZ ''01:02:03' , formattedOffset , ''''.	self assert: result firstFieldOfFirstRecord equals: (Time hour: 1 minute: 2 second: 3).	"TIME WITH TIME ZONE is shifted when the time zone differs"	result := client query: 'SELECT TIMETZ ''01:02:03+00:00'''.	self 		assert: result firstFieldOfFirstRecord 		equals: ((Time hour: 1 minute: 2 second: 3) addTime: offset).! !!P3ClientTest methodsFor: 'tests'!testConvenienceMetaAccess	self deny: client listDatabases isEmpty.	self assert: (client listSchemas includes: 'public').	self assert: (client listTablesInSchema: 'public') isCollection.! !!P3ClientTest methodsFor: 'tests'!testEnum	| result |	result := client 		execute: 'DROP TABLE IF EXISTS table1;';		execute: 'DROP TYPE IF EXISTS mood';		execute: 'CREATE TYPE mood AS ENUM (''sad'', ''ok'', ''happy'');';		execute: 'CREATE TABLE table1 (name text, current_mood mood );';		execute: 'INSERT INTO table1 VALUES (''Moe'', ''happy'');'.					result := client loadEnums.		self assert: (result includes: #mood).			result := client query: 'SELECT * FROM table1 WHERE current_mood = ''happy'';'.			self assert: result firstRecord equals: #('Moe' #happy)		! !!P3ClientTest methodsFor: 'tests'!testPathConversion	| result |	result := client query: 'SELECT path ''((1,2),(3,4),(5,6))'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Path points: { P3Point x: 1 y: 2. P3Point x: 3 y: 4. P3Point x: 5 y: 6 }).	self assert: result firstFieldOfFirstRecord isClosed.	result := client query: 'SELECT path ''[(1,2),(3,4),(5,6)]'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Path openPoints: { P3Point x: 1 y: 2. P3Point x: 3 y: 4. P3Point x: 5 y: 6 }).	self assert: result firstFieldOfFirstRecord isOpen.! !!P3ClientTest methodsFor: 'tests'!testPointConversion	| result |	result := client query: 'SELECT point (1,2)'.	self assert: result firstFieldOfFirstRecord equals: (P3Point x: 1 y: 2).	result := client query: 'SELECT point (0,0)'.	self assert: result firstFieldOfFirstRecord equals: P3Point zero.	result := client query: 'SELECT point (1,1)'.	self assert: result firstFieldOfFirstRecord equals: P3Point unit.	result := client query: 'SELECT point (1.3,-1.5)'.	self assert: (result firstFieldOfFirstRecord x closeTo: 1.3).	self assert: (result firstFieldOfFirstRecord y closeTo: -1.5).! !!P3ClientTest methodsFor: 'tests'!testConnection	self assert: client isConnected.	self assert: client isWorking.! !!P3ClientTest methodsFor: 'tests'!testQueryCatalog	| result |	result := client query: 'SELECT schemaname,tablename FROM pg_catalog.pg_tables'.	"there are two columns"	self assert: result numberOfColumns equals: 2.	"this was a select"	self assert: ($ split: result firstResult) first equals: 'SELECT'.	"the select returned a count for the number of dataRows"	self assert: result rowCount equals: result numberOfRecords.	"each dataRow has two fields"	self assert: (result data allSatisfy: [ :each | each size = 2])! !!P3ClientTest methodsFor: 'tests'!testTimeout	"Reconnect with an explicit timeout"	client close.	client url: Url.	client timeout: 1. "second"	self assert: client isWorking.	"The following (sleeping for 0.5 seconds) should just pass successfully"	client execute: 'SELECT pg_sleep(0.5)'.	"While the following (sleeping for 1.5 seconds) should time out"	self should: [ client execute: 'SELECT pg_sleep(1.5)' ] raise: ConnectionTimedOut ! !!P3ClientTest methodsFor: 'tests'!testCircleConversion	| result |	result := client query: 'SELECT circle ''<(1,2),100>'''.	self 		assert: result firstFieldOfFirstRecord 		equals: (P3Circle center: (P3Point x: 1 y: 2) radius: 100).	result := client query: 'SELECT circle ''<(0,0),1>'''.	self 		assert: result firstFieldOfFirstRecord 		equals: P3Circle unit.	result := client query: 'SELECT circle ''<(1.5,-1.5),20.5>'''.	self assert: (result firstFieldOfFirstRecord center x closeTo: 1.5).	self assert: (result firstFieldOfFirstRecord center y closeTo: -1.5).	self assert: (result firstFieldOfFirstRecord radius closeTo: 20.5).! !!P3ClientTest methodsFor: 'tests'!testError	self should: [ client query: 'SELECT * FROM abcdef' ] raise: P3Error! !!P3ClientTest methodsFor: 'tests'!testEmptyString	| result |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, string VARCHAR)'.	client execute: 'INSERT INTO table1 (id, string) VALUES (1, '''')'.	result := client query: 'SELECT id, string FROM table1 WHERE id = 1'.	self assert: result firstRecord equals: #(1 '').	client execute: 'INSERT INTO table1 (id, string) VALUES (2, NULL)'.	result := client query: 'SELECT id, string FROM table1 WHERE id = 2'.	self assert: result firstRecord equals: #(2 nil).	client execute: 'DROP TABLE table1'! !!P3ClientTest methodsFor: 'tests'!testIntegerConversion	| result |	result := client query: 'SELECT i::integer FROM (VALUES (-1), (1), (NULL), (1234567890)) t(i)'.	self assert: result data equals: #((-1) (1) (nil) (1234567890))! !!P3ClientTest methodsFor: 'running'!setUp	super setUp.	client := P3Client new.	client url: self class url.	client connect! !!P3ClientTest methodsFor: 'running'!tearDown	client close.	super tearDown! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3ClientTest class	instanceVariableNames: ''!!P3ClientTest class methodsFor: 'accessing'!url	"Return the default connection URL to use for P3 clients in the unit tests.	Note that the default here corresponds to the default on Travis CI's postgresql service,	user postgres with a blank password on localhost.	You should set an appropriate connection string yourself, see #url:"		^ Url ifNil: [ Url := 'psql://postgres@localhost' ]! !!P3ClientTest class methodsFor: 'accessing'!url: stringOrUrl	"Set the connection URL to be used for P3 Clients in the unit tests.	The general syntax is psql://sven:secret@localhost:5432/database	The minimal form is psql://user@localhost (a user, blank password, localhost)"		Url := stringOrUrl asUrl! !TestCase subclass: #P3ConnectionPoolTest	instanceVariableNames: 'pool'	classVariableNames: ''	package: 'P3-Tests'!!P3ConnectionPoolTest commentStamp: '' prior: 0!P3ConnectionPoolTest holds unit tests for the P3ConnectionPool class.I reuse the configuration of P3ClientTest.!!P3ConnectionPoolTest methodsFor: 'tests'!testError	self assert: pool size equals: 0.	self 		should: [ pool withConnection: [ :p3Client | 							p3Client query: 'SELECT * FROM abcdef'] ] 		raise: P3Error.	self assert: pool size equals: 0! !!P3ConnectionPoolTest methodsFor: 'tests'!testOne	self assert: pool size equals: 0.	self 		assert: (pool withConnection: [ :p3Client | 							(p3Client query: 'SELECT 1+2') firstFieldOfFirstRecord ]) 		equals: 3.	self 		assert: (pool withConnection: [ :p3Client | 							(p3Client query: 'SELECT 10-2') firstFieldOfFirstRecord ]) 		equals: 8.	self assert: pool size equals: 1! !!P3ConnectionPoolTest methodsFor: 'tests'!testWarmUp	self assert: pool size equals: 0.	pool warmUp.	self assert: pool size equals: pool capacity.	pool withConnection: [ :p3Client | 		p3Client query: 'SELECT table_name FROM information_schema.tables' ].	self assert: pool size equals: pool capacity.	pool close.	self assert: pool size equals: 0! !!P3ConnectionPoolTest methodsFor: 'running'!setUp	super setUp.	pool := P3ConnectionPool new.	pool url: P3ClientTest url! !!P3ConnectionPoolTest methodsFor: 'running'!tearDown	pool close! !TestCase subclass: #P3FormattedStatementTest	instanceVariableNames: 'client'	classVariableNames: ''	package: 'P3-Tests'!!P3FormattedStatementTest commentStamp: '' prior: 0!P3FormattedStatementTest holds unit tests for the P3FormattedStatement class.I reuse the configuration of P3ClientTest.!!P3FormattedStatementTest methodsFor: 'testing'!isServerVersionAtLeastMajor: major minor: minor	| serverVersion |	serverVersion := ($. split: client serverVersion) collect: #asNumber.	^ serverVersion first > major		or:			[ serverVersion first = major and: [ serverVersion second >= minor ] ]! !!P3FormattedStatementTest methodsFor: 'running'!setUp	super setUp.	client := P3Client new.	client url: P3ClientTest url.	client connect! !!P3FormattedStatementTest methodsFor: 'running'!tearDown	client close.	super tearDown! !!P3FormattedStatementTest methodsFor: 'tests'!testStrings	| statement string result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT)'.		string := 'single '' dounble '' dollar $ backslash \ euro €'.		statement := client format: 'INSERT INTO table1 (id, name) VALUES ($1, $2)'.	statement execute: { 123. string }.		statement := client format: 'SELECT name FROM table1 WHERE id = $1'.	result := statement query: { 123 }.		self assert: result firstFieldOfFirstRecord equals: string.		client execute: 'DROP TABLE table1'! !!P3FormattedStatementTest methodsFor: 'tests'!testInterval	| statement intervals result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL, time_interval INTERVAL)'.		intervals := { { P3Interval zero }. { P3Interval years: 1 months: 2 days: 3 hours: 4 minutes: 5 seconds: 6 } }.		statement := client format: 'INSERT INTO table1 (time_interval) VALUES ($1)'.	statement executeBatch: intervals.		result := client query: 'SELECT time_interval FROM table1 ORDER BY id'.		self assert: result data equals: intervals.		client execute: 'DROP TABLE table1'! !!P3FormattedStatementTest methodsFor: 'tests'!testGeometricTypes	| p1 p2 p3 points row1 row2 row3 statement result |	(self isServerVersionAtLeastMajor: 9 minor: 4) ifFalse: [ ^ self skip ].		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL, p POINT, b BOX, c CIRCLE, l1 LINE, l2 LSEG, p1 POLYGON, p2 PATH)'.		p1 := P3Point x: 1 y: 2.	p2 := P3Point x: 3 y: 4.	p3 := P3Point x: 5 y: 6.	points := { p1. p2. p3}.	row1 := { P3Point unit. P3Circle unit. P3Box unit. P3Line xAxis. P3LineSegment xAxisUnit.		P3Polygon points: points. P3Path points: points }. 	row2 := { P3Point zero. P3Circle unit. P3Box unit. P3Line yAxis. P3LineSegment yAxisUnit.		P3Polygon points: points reversed. P3Path openPoints: points reversed }.	row3 := Array new: 7 withAll: nil.		statement := client format: 'INSERT INTO table1 (p, c, b, l1, l2, p1, p2) VALUES ($1, $2, $3, $4, $5, $6, $7)'.	statement executeBatch: { row1. row2. row3 }.		result := client query: 'SELECT p, c, b, l1, l2, p1, p2 FROM table1 ORDER BY id'.	self assert: result records equals: { row1. row2. row3 }.		client execute: 'DROP TABLE table1'! !!P3FormattedStatementTest methodsFor: 'tests'!testByteArray	| statement bytes result |		client execute: 'DROP TABLE IF EXISTS testBytea'.	client execute: 'CREATE TABLE testBytea (id INT, bytes BYTEA)'.		bytes := #[ 0 1 2 3 4 254 255 ].			statement := client format: 'INSERT INTO testBytea (id, bytes) VALUES ($1, $2)'.	statement execute: { 100. bytes }.		statement := client format: 'SELECT bytes FROM testBytea WHERE id = $1'.	result := statement query: #( 100 ).		self assert: result firstFieldOfFirstRecord equals: bytes.		client execute: 'DROP TABLE testBytea'! !!P3FormattedStatementTest methodsFor: 'tests'!testBitString	| statement bitString fixedBitString result |		client execute: 'DROP TABLE IF EXISTS testBits'.	client execute: 'CREATE TABLE testBits (id INT, b1 BIT, b2 BIT VARYING, b3 BIT(8), b4 BIT VARYING(8))'.		bitString := P3BitString bits: 2r11001111.	fixedBitString := P3FixedBitString bits: 2r11110011.		statement := client format: 'INSERT INTO testBits (id, b1, b2, b3, b4) VALUES ($1, $2, $3, $4, $5)'.	statement execute: { 100. P3FixedBitString one. bitString. fixedBitString. bitString }.		statement := client format: 'SELECT b1, b2, b3, b4 FROM testBits WHERE id = $1'.	result := statement query: #( 100 ).		self assert: result firstRecord equals: { P3FixedBitString one. bitString. fixedBitString. bitString }.		client execute: 'DROP TABLE testBits'! !!P3FormattedStatementTest methodsFor: 'tests'!testChronology	| result statement |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL PRIMARY KEY, name TEXT, timestamp_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP, date_created DATE DEFAULT CURRENT_DATE, time_created TIME DEFAULT CURRENT_TIME)'.	statement := client format: 'INSERT INTO table1 (name) VALUES ($1)'.	statement execute: { 'Chronology' }.	result := client query: 'SELECT id, name, timestamp_created, date_created, time_created FROM table1 WHERE id = 1'.	self assert: result firstRecord first equals: 1.	self assert: result firstRecord second equals: 'Chronology'.	self assert: (DateAndTime now - result firstRecord third) abs < 30 seconds.	self assert: (Date today - result firstRecord fourth) abs < 30 seconds.	self assert: (Time now asSeconds - result firstRecord fifth asSeconds) abs < 30.	statement := client format: 'INSERT INTO table1 (name, timestamp_created, date_created, time_created) VALUES ($1, $2, $3, $4)'.	statement execute: { 'Pharo'. DateAndTime now. Date today. Time now }.	result := client query: 'SELECT id, name, timestamp_created, date_created, time_created FROM table1 WHERE id = 2'.	self assert: result firstRecord first equals: 2.	self assert: result firstRecord second equals: 'Pharo'.	self assert: (DateAndTime now - result firstRecord third) abs < 30 seconds.	self assert: (Date today - result firstRecord fourth) abs < 30 seconds.	self assert: (Time now asSeconds - result firstRecord fifth asSeconds) abs < 30.	client execute: 'DROP TABLE table1'! !!P3FormattedStatementTest methodsFor: 'tests'!testNull	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.		statement := client format: 'INSERT INTO table1 (id, name, enabled) VALUES ($1, $2, $3)'.	statement execute: #( nil nil nil	).		result := client query: 'SELECT id, name, enabled FROM table1'.	self assert: result firstRecord equals: #( nil nil nil ).		client execute: 'DROP TABLE table1'! !!P3FormattedStatementTest methodsFor: 'tests'!testInClause	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT)'.		statement := client format: 'INSERT INTO table1 (id, name) VALUES ($1,$2)'.	statement executeBatch: #(		( 1 'Hello World' )		( 2 'Greetings' )		( 3 'From Mars' )	).	statement close.		statement := client format: 'SELECT id, name FROM table1 WHERE id = ANY ($1) ORDER BY id'.	result := statement query: { P3ValuesArray withAll: #( 2 3 ) }.	self assert: result records equals: #( (2 'Greetings') (3 'From Mars') ).		result := statement query: { P3ValuesArray withAll: #( 3 ) }.	self assert: result records equals: #( (3 'From Mars') ).		result := statement query: { P3ValuesArray withAll: #( 666 ) }.	self assert: result records equals: #( ).		statement close.	client execute: 'DROP TABLE table1'.! !!P3FormattedStatementTest methodsFor: 'tests'!testSimple	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.		statement := client format: 'INSERT INTO table1 (id, name, enabled) VALUES ($1, $2, $3)'.	statement executeBatch: #(		( 123 'Hello World' true )		( 345 'Greetings' false )		( 567 'From Mars' true )	).		statement := client format: 'SELECT name, enabled FROM table1 WHERE id >= $1 ORDER BY id'.	result := statement query: #( 345 ).	self assert: result records equals: #( ('Greetings' false) ('From Mars' true ) ).		result := statement query: #( 567 ).	self assert: result records equals: #( ('From Mars' true ) ).		result := statement query: #( 800 ).	self assert: result records equals: #( ).		client execute: 'DROP TABLE table1'! !TestCase subclass: #P3PreparedStatementTest	instanceVariableNames: 'client'	classVariableNames: ''	package: 'P3-Tests'!!P3PreparedStatementTest commentStamp: '' prior: 0!P3PreparedStatementTest holds unit tests for the P3PreparedStatement class.I reuse the configuration of P3ClientTests. Example:  P3ClientTest url: 'psql://sven:secret@localhost:5432/database'.!!P3PreparedStatementTest methodsFor: 'testing'!isServerVersionAtLeastMajor: major minor: minor	| serverVersion |	serverVersion := ($. split: client serverVersion) collect: #asNumber.	^ serverVersion first > major		or:			[ serverVersion first = major and: [ serverVersion second >= minor ] ]! !!P3PreparedStatementTest methodsFor: 'tests'!testSimpleInsertStatement	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.		statement := client prepare: 'INSERT INTO table1 (id, name, enabled) VALUES ($1,$2,$3)'.	statement execute: #( 123 'Hello World' true ).	statement execute: #( 345 'Greetings' false ).		statement executeBatch: #(		#( 111 'Hello Mars' true )		#( 333 'Hello Moon' false ) ).	statement close.		result := client query: 'SELECT id, name, enabled FROM table1 ORDER BY id'.	self assert: result records size equals: 4.! !!P3PreparedStatementTest methodsFor: 'tests'!testGeometricTypes	| p1 p2 p3 points row1 row2 row3 statement result |	(self isServerVersionAtLeastMajor: 9 minor: 4) ifFalse: [ ^ self skip ].		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL, p POINT, b BOX, c CIRCLE, l1 LINE, l2 LSEG, p1 POLYGON, p2 PATH)'.		p1 := P3Point x: 1 y: 2.	p2 := P3Point x: 3 y: 4.	p3 := P3Point x: 5 y: 6.	points := { p1. p2. p3}.	row1 := { P3Point unit. P3Circle unit. P3Box unit. P3Line xAxis. P3LineSegment xAxisUnit.		P3Polygon points: points. P3Path points: points }. 	row2 := { P3Point zero. P3Circle unit. P3Box unit. P3Line yAxis. P3LineSegment yAxisUnit.		P3Polygon points: points reversed. P3Path openPoints: points reversed }.	row3 := Array new: 7 withAll: nil.		statement := client prepare: 'INSERT INTO table1 (p, c, b, l1, l2, p1, p2) VALUES ($1, $2, $3, $4, $5, $6, $7)'.	statement executeBatch: { row1. row2. row3 }.		result := client query: 'SELECT p, c, b, l1, l2, p1, p2 FROM table1 ORDER BY id'.	self assert: result records equals: { row1. row2. row3 }.		client execute: 'DROP TABLE table1'! !!P3PreparedStatementTest methodsFor: 'tests'!testNamedPreparedStatement	| result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.		client 		prepare: 'INSERT INTO table1 (id, name, enabled) VALUES ($1,$2,$3)'		named: 'table1_insert1'.	(client preparedStatementNamed: 'table1_insert1') executeBatch: #(		( 123 'Hello World' true )		( 345 'Greetings' false )		( 567 'From Mars' true )	).	(client preparedStatementNamed: 'table1_insert1') close.	self should: [ client preparedStatementNamed: 'table1_insert1' ] raise: NotFound.		client 		prepare: 'SELECT name, enabled FROM table1 where id >= $1 order by id'		named: 'table1_select1'.	result := (client preparedStatementNamed: 'table1_select1') query: #( 345 ).	self assert: result records equals: #( ('Greetings' false) ('From Mars' true ) ).		result := (client preparedStatementNamed: 'table1_select1') query: #( 567 ).	self assert: result records equals: #( ('From Mars' true ) ).		result := (client preparedStatementNamed: 'table1_select1') query: #( 800 ).	self assert: result records equals: #( ).		(client preparedStatementNamed: 'table1_select1') close.! !!P3PreparedStatementTest methodsFor: 'tests'!testScaledDecimal	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, nr NUMERIC(10,2))'.		statement := client prepare: 'INSERT INTO table1 (id, nr) VALUES ($1,$2)'.	statement execute: #( 10 100 ).	statement execute: #( 20 100.12 ).	statement execute: #( 30 100.12s2 ).	statement execute: #( 40 100.123s2 ).	statement execute: #( 50 100.129s2 ).	statement close.		statement := client prepare: 'SELECT nr FROM table1 ORDER BY id'.	result := statement query: #( ).	statement close.		self assert: (result data collect: [ :row | row first asScaledDecimal ]) asArray		equals: #( 100 100.12s2 100.12s2 100.12s2 100.13s2 ).	! !!P3PreparedStatementTest methodsFor: 'tests'!testSelectStatement	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.		statement := client prepare: 'INSERT INTO table1 (id, name, enabled) VALUES ($1,$2,$3)'.	statement executeBatch: #(		( 123 'Hello World' true )		( 345 'Greetings' false )		( 567 'From Mars' true )	).	statement close.		statement := client prepare: 'SELECT name, enabled FROM table1 where id >= $1 order by id'.	result := statement query: #( 345 ).	self assert: result records equals: #( ('Greetings' false) ('From Mars' true ) ).		result := statement query: #( 567 ).	self assert: result records equals: #( ('From Mars' true ) ).		result := statement query: #( 800 ).	self assert: result records equals: #( ).		statement close.! !!P3PreparedStatementTest methodsFor: 'tests'!testInterval	| statement intervals result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL, time_interval INTERVAL)'.		intervals := { { P3Interval zero }. { P3Interval years: 1 months: 2 days: 3 hours: 4 minutes: 5 seconds: 6 } }.		statement := client prepare: 'INSERT INTO table1 (time_interval) VALUES ($1)'.	statement executeBatch: intervals.		result := client query: 'SELECT time_interval FROM table1 ORDER BY id'.		self assert: result data equals: intervals.		client execute: 'DROP TABLE table1'! !!P3PreparedStatementTest methodsFor: 'tests'!testBulkInsertAndSelect	| insertStatement result selectStatement |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL PRIMARY KEY, created_at TIMESTAMP DEFAULT NOW(), name TEXT)'.		insertStatement := client prepare: 'INSERT INTO table1 (name) VALUES ($1) RETURNING id, created_at'.	result := insertStatement queryAll: ((1 to: 100) collect: [ :index | Array with: ('Text #', index printString) ]).		self assert: result size equals: 100.	result do: [ :each |		self assert: each data size equals: 1.		self assert: each firstRecord size equals: 2 ].		selectStatement := client prepare: 'SELECT name FROM table1 WHERE id = $1 AND created_at = $2'.	result := selectStatement queryAll: (result collect: [ :each | each firstRecord ]).		self assert: result size equals: 100.	result doWithIndex: [ :each :index |		self assert: each data size equals: 1.		self assert: each firstRecord equals: (Array with: 'Text #', index printString) ].	insertStatement close.	selectStatement close.! !!P3PreparedStatementTest methodsFor: 'tests'!testBinaryColumn	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, bytes BYTEA)'.		statement := client prepare: 'INSERT INTO table1 (id, bytes) VALUES ($1,$2)'.	statement execute: #( 123 #[ 100 102 104 200 255 0 1 2 ] ).	statement execute: #( 345 #[ 100 102 104 106 108 100 102 104 106 108 ]  ).	statement close.		statement := client prepare: 'SELECT bytes from table1 WHERE id = $1'.	result := statement queryAll: #( ( 123 ) ( 345 ) ).	statement close.	self assert: #( #[ 100 102 104 200 255 0 1 2 ] ) equals: (result at: 1) firstRecord.	self assert: #( #[ 100 102 104 106 108 100 102 104 106 108 ] ) equals: (result at: 2) firstRecord.	! !!P3PreparedStatementTest methodsFor: 'tests'!testInsertNull	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT)'.		statement := client prepare: 'INSERT INTO table1 (id, name) VALUES ($1,$2)'.	result := statement executeBatch: #(		( 123 'Hello World' )		( 345 nil )	).		self assert: result size equals: 2.	result do: [ :each |		self assert: each equals: 'INSERT 0 1' ].		statement close.! !!P3PreparedStatementTest methodsFor: 'tests'!testBatchInsertStatement	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.		statement := client prepare: 'INSERT INTO table1 (id, name, enabled) VALUES ($1,$2,$3)'.	result := statement executeBatch: #(		( 123 'Hello World' true )		( 345 'Greetings' false )		( 567 'From Mars' true )	).		self assert: result size equals: 3.	result do: [ :each |		self assert: each equals: 'INSERT 0 1' ].		statement close.! !!P3PreparedStatementTest methodsFor: 'tests'!testLongQueries	"Test fix for issue: Prepared statements error when query is long and differs slightly at the end	https://github.com/svenvc/P3/issues/20"	| statement select1 select2 result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.		statement := client prepare: 'INSERT INTO table1 (id, name, enabled) VALUES ($1,$2,$3)'.	statement executeBatch: #(		( 123 'Hello World' true )		( 345 'Greetings' false )		( 567 'From Mars' true )	).	statement close.		select1 := client prepare: 'SELECT name, enabled FROM table1 /* long and boring piece of comment */ WHERE id >= $1 order by id'.	select2 := client prepare: 'SELECT name, enabled FROM table1 /* long and boring piece of comment */ WHERE id < $1 order by id'.	result := select1 query: #( 345 ).	self assert: result records equals: #( ('Greetings' false) ('From Mars' true ) ).		result := select2 query: #( 345 ).	self assert: result records equals: #( ('Hello World' true ) ).	self assert: select1 name size < 64.		statement close.	select1 close.	select2 close.! !!P3PreparedStatementTest methodsFor: 'tests'!testBitString	| statement bitString fixedBitString result |		client execute: 'DROP TABLE IF EXISTS testBits'.	client execute: 'CREATE TABLE testBits (id INT, b1 BIT, b2 BIT VARYING, b3 BIT(8), b4 BIT VARYING(8))'.		bitString := P3BitString bits: 2r11001111.	fixedBitString := P3FixedBitString bits: 2r11110011.		statement := client prepare: 'INSERT INTO testBits (id, b1, b2, b3, b4) VALUES ($1, $2, $3, $4, $5)'.	statement execute: { 100. P3FixedBitString one. bitString. fixedBitString. bitString }.		statement := client prepare: 'SELECT b1, b2, b3, b4 FROM testBits WHERE id = $1'.	result := statement query: #( 100 ).		self assert: result firstRecord equals: { P3FixedBitString one. bitString. fixedBitString. bitString }.		client execute: 'DROP TABLE testBits'! !!P3PreparedStatementTest methodsFor: 'tests'!testChronology	| result statement |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id SERIAL PRIMARY KEY, name TEXT, timestamp_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP, date_created DATE DEFAULT CURRENT_DATE, time_created TIME DEFAULT CURRENT_TIME)'.	statement := client prepare: 'INSERT INTO table1 (name) VALUES ($1)'.	statement execute: { 'Chronology' }.	statement close.	result := client query: 'SELECT id, name, timestamp_created, date_created, time_created FROM table1 WHERE id = 1'.	self assert: result firstRecord first equals: 1.	self assert: result firstRecord second equals: 'Chronology'.	self assert: (DateAndTime now - result firstRecord third) abs < 30 seconds.	self assert: (Date today - result firstRecord fourth) abs < 30 seconds.	self assert: (Time now asSeconds - result firstRecord fifth asSeconds) abs < 30.	statement := client prepare: 'INSERT INTO table1 (name, timestamp_created, date_created, time_created) VALUES ($1, $2, $3, $4)'.	statement execute: { 'Pharo'. DateAndTime now. Date today. Time now }.	statement close.	result := client query: 'SELECT id, name, timestamp_created, date_created, time_created FROM table1 WHERE id = 2'.	self assert: result firstRecord first equals: 2.	self assert: result firstRecord second equals: 'Pharo'.	self assert: (DateAndTime now - result firstRecord third) abs < 30 seconds.	self assert: (Date today - result firstRecord fourth) abs < 30 seconds.	self assert: (Time now asSeconds - result firstRecord fifth asSeconds) abs < 30.	client execute: 'DROP TABLE table1'! !!P3PreparedStatementTest methodsFor: 'tests'!testInClause	| statement result |		client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT)'.		statement := client prepare: 'INSERT INTO table1 (id, name) VALUES ($1,$2)'.	statement executeBatch: #(		( 1 'Hello World' )		( 2 'Greetings' )		( 3 'From Mars' )	).	statement close.		statement := client prepare: 'SELECT id, name FROM table1 WHERE id = ANY ($1) ORDER BY id'.	result := statement query: { P3ValuesArray withAll: #( 2 3 ) }.	self assert: result records equals: #( (2 'Greetings') (3 'From Mars') ).		result := statement query: { P3ValuesArray withAll: #( 3 ) }.	self assert: result records equals: #( (3 'From Mars') ).		result := statement query: { P3ValuesArray withAll: #( 666 ) }.	self assert: result records equals: #( ).		statement close.	client execute: 'DROP TABLE table1'.! !!P3PreparedStatementTest methodsFor: 'tests'!testMultipleInsertStatements	| statement1 statement2 |	client execute: 'DROP TABLE IF EXISTS table1'.	client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT)'.	client execute: 'DROP TABLE IF EXISTS table2'.	client execute: 'CREATE TABLE table2 (id INTEGER, enabled BOOLEAN)'.	statement1 := client prepare: 'INSERT INTO table1 (id, name) VALUES ($1,$2)'.	statement2 := client prepare: 'INSERT INTO table2 (id, enabled) VALUES ($1,$2)'.		statement1 execute: #( 22 'Hi!!' ).	statement2 executeBatch: #( ( 44 false ) ( 55 true ) ).	statement1 close.	statement2 close.	! !!P3PreparedStatementTest methodsFor: 'running'!setUp	super setUp.	client := P3Client new.	client url: P3ClientTest url.	client timeout: 10. "second"	client connect! !!P3PreparedStatementTest methodsFor: 'running'!tearDown	client close.	super tearDown! !