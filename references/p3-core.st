Object subclass: #P3Client	instanceVariableNames: 'connection session settings properties converter message'	classVariableNames: ''	package: 'P3-Core'!!P3Client commentStamp: '' prior: 0!I am P3Client, a lean and mean PostgreSQL client.PostgreSQL, often simply Postgres, is a free and open-source, ACID-compliant and transactional object-relational database management system (ORDBMS).I use frontend/backend protocol 3.0 (PostgreSQL version 7.4 [2003] and later), implementing the simple query cycle. I support plaintext and md5 password authentication. When SQL queries return row data, I efficiently convert incoming data to objects. I support most common PostgreSQL types (P3Converter supportedTypes).I can be configured manually or through a URL.  P3Client new url: 'psql://username:password@localhost:5432/databasename'.Not all properties need to be specified, the minimum is the following URL.  P3Client new url: 'psql://user@localhost'.I have a minimal public protocol, basically #query: (#execute: is an alias).Opening a connection to the server (#open) and running the authentication and startup protocols (#connect) are done automatically when needed from #query.I also support SSL connections. Use #connectSSL to initiate such a connection.I represent a single database connection or session, I am not thread safe.Examples Here is the simplest test that does an actual query, it should return true.    (P3Client new url: 'psql://sven@localhost') in: [ :client |        [ client isWorking ] ensure: [ client close ] ].Here is how to create a simple table with some rows in it.    (P3Client new url: 'psql://sven@localhost') in: [ :client |        client execute: 'DROP TABLE IF EXISTS table1'.        client execute: 'CREATE TABLE table1 (id INTEGER, name TEXT, enabled BOOLEAN)'.        client execute: 'INSERT INTO table1 (id, name, enabled) VALUES (1, ''foo'', true)'.        client execute: 'INSERT INTO table1 (id, name, enabled) VALUES (2, ''bar'', false)'.        client close ].	Now we can query the contents of the simple table we just created.    (P3Client new url: 'psql://sven@localhost') in: [ :client |        [ client query: 'SELECT * FROM table1' ] ensure: [ client close ] ].The result is an instance of P3Result    a P3Result('SELECT 2' 2 records 3 colums)P3Result contains 3 elements,  results, descriptions & data:- Results is a string (collection of strings for multiple embedded queries) indicating successful execution.- Descriptions is a collection of row field description objects.- Data is a collection of rows with fully converted field values as objects.The data itself is an array with 2 sub arrays, one for each record.    #( #(1 'foo' true) #(2 'bar' false) )Finally we can clean up.    (P3Client new url: 'psql://sven@localhost') in: [ :client |        [ client execute: 'DROP TABLE table1' ] ensure: [ client close ] ].References -  https://postgresql.org-  https://en.wikipedia.org/wiki/PostgreSQL-  https://www.postgresql.org/docs/9.6/static/protocol.htmlSee also P3DatabaseDriver, an interface between Glorp, an advanced object-relational mapper, and me.!!P3Client methodsFor: 'error handling'!errorNoticeInfo: payload	| info fieldType |	info := Dictionary new.	[ (fieldType := payload next) isZero ] 		whileFalse: [ 			info 				at: fieldType asCharacter 				put: (self converter asciiCStringFrom: payload) ].	^ info! !!P3Client methodsFor: 'error handling'!signal: exceptionClass using: info	exceptionClass new 		info: info; 		signal! !!P3Client methodsFor: 'private messages'!sslRequestMessage	^ #[4 210 22 47] "1234 5678"! !!P3Client methodsFor: 'private messages'!clearTextPasswordMessage	self password ifNil: [ P3Error passwordRequired signal ].	^ self asCString: self password! !!P3Client methodsFor: 'private messages'!startupMessage	^ ByteArray streamContents: [ :out |			out nextPutAll: #[ 0 3 0 0 ]. "Protocol major.minor 3.0"			out nextPutAll: (self asCString: 'user').			out nextPutAll: (self asCString: self user).			self database ifNotNil: [ 				out nextPutAll: (self asCString: 'database').				out nextPutAll: (self asCString: self database) ].			out nextPut: 0 ]! !!P3Client methodsFor: 'private messages'!md5PasswordMessage: salt	"concat('md5', md5(concat(md5(concat(password, username)), random-salt))).	Keep in mind the md5() function returns its result as a hex string."		| credential salted |	self password ifNil: [ P3Error passwordRequired signal ].	credential := (MD5 hashMessage: self password , self user) hex.	salted := (MD5 hashMessage: credential , salt) hex.	^ self asCString: 'md5' , salted! !!P3Client methodsFor: 'configuration'!loadEnums	"Define converters for all ENUM type OIDs currently visible, converting their values to Symbols.	In PSQL ENUMs constitute distinct type OIDs and must be thus be defined before they can be used in results.	Since new ENUMs can be added at any time, there is no good/correct time to call this method.	Either call #loadEnums as an initialization for a new connection, or after (all) ENUMs are (re)defined.	Return the collection of enum type names processed."		^ self listEnums collect: [ :each |		self converter			mapOid: each first 			type: each second asSymbol 			to: #convertSymbolFrom:length:description:.		each second asSymbol ]! !!P3Client methodsFor: 'convenience'!listSchemas	"Return the list of known schema or namespace names"		^ (self query: 'SELECT nspname FROM pg_namespace ORDER BY 1') firstColumnData! !!P3Client methodsFor: 'convenience'!listDatabases	"Return the list of known database names"		^ (self query: 'SELECT datname FROM pg_database ORDER BY 1') firstColumnData! !!P3Client methodsFor: 'convenience'!listTablesInSchema: schemaName	"Return the list of known table names in a given schema"		| query |	query := 'SELECT tablename FROM pg_tables WHERE schemaname=''{1}'' ORDER BY 1' 		format: { schemaName }.	^ (self query: query) firstColumnData! !!P3Client methodsFor: 'convenience'!listEnums	"Return the list of currently defined/visible ENUMs as a collection of type OID, type name pairs.	See also #loadEnums"		^ (self query: 'SELECT oid, typname FROM pg_type WHERE oid IN (SELECT DISTINCT enumtypid FROM pg_enum)') data! !!P3Client methodsFor: 'input/output'!writeMessageNoFlush: payload	| size |	size := payload size + 4.	4 to: 1 by: -1 do: [ :index | connection nextPut: (size digitAt: index) ].	connection nextPutAll: payload.! !!P3Client methodsFor: 'input/output'!writeDescribeMessage: aName type: aChar	"Type $S to describe a prepared statement; or $P to describe a portal."	| msgBuilder |	msgBuilder := self newMessageBuilder.	msgBuilder		nextPutByte: aChar asInteger;		nextPutString: aName.	self writeMessageNoFlush: msgBuilder asBytes tag: $D! !!P3Client methodsFor: 'input/output'!writeSyncMessage	self writeMessage: #[] tag: $S. ! !!P3Client methodsFor: 'input/output'!writeQueryMessage: queryString	| encoder size |	connection nextPut: $Q asInteger.	encoder := self converter encoder.	size := (encoder encodedByteCountForString: queryString) + 5.	4 to: 1 by: -1 do: [ :index | connection nextPut: (size digitAt: index) ].	queryString do: [ :each | encoder nextPut: each toStream: connection ].	connection nextPut: 0.	connection flush! !!P3Client methodsFor: 'input/output'!readMessageCloseAfterError	"During authentication and startup errors result in the server closing the connection, do the same"		^ self readMessageOnError: [ self close ]! !!P3Client methodsFor: 'input/output'!writeParseMessage: queryString name: statementName types: paramDataTypes	| msgBuilder |	msgBuilder := self newMessageBuilder.	msgBuilder		nextPutString: statementName;		nextPutString: queryString;		nextPutInt16: paramDataTypes size.	paramDataTypes do: [ :each | msgBuilder nextPutInt32: each ].	self writeMessage: msgBuilder asBytes tag: $P 	! !!P3Client methodsFor: 'input/output'!readMessageOnError: block	message readFrom: connection.	message tag = $E 		ifTrue: [ | info |			info := self errorNoticeInfo: message readStream.			block cull: info.			self signal: P3Error using: info ].	message tag = $N 		ifTrue: [ | info |			info := self errorNoticeInfo: message readStream.			self signal: P3Notification using: info.			^ self readMessage ].	^ message! !!P3Client methodsFor: 'input/output'!writeMessage: payload tag: tag	connection nextPut: tag asInteger.	self writeMessage: payload! !!P3Client methodsFor: 'input/output'!writeMessageNoFlush: payload tag: tag	connection nextPut: tag asInteger.	self writeMessageNoFlush: payload! !!P3Client methodsFor: 'input/output'!readMessage	"During normal operations, an error is reported followed by a ready for query so that we can continue to use the connection"		^ self readMessageOnError: [ self assert: self readMessage tag = $Z ]! !!P3Client methodsFor: 'input/output'!writeMessage: payload	| size |	size := payload size + 4.	4 to: 1 by: -1 do: [ :index | connection nextPut: (size digitAt: index) ].	payload notEmpty 		ifTrue: [ connection nextPutAll: payload ].	connection flush! !!P3Client methodsFor: 'accessing'!database	"Return the database name I (want to) connect to.	For the default, nil is used."		^ settings at: #database ifAbsent: [ nil ]! !!P3Client methodsFor: 'accessing'!preparedStatementNamed: name	"Return the P3PreparedStatement previously created under name, else signal NotFound"		properties 		at: 'prepared_statements'		ifPresent: [ :preparedStatements |			preparedStatements 				at: name 				ifPresent: [ :preparedStatement | ^ preparedStatement ] ].	NotFound signalFor: name in: self! !!P3Client methodsFor: 'accessing'!converter	"Return the converter that I am using.	It holds the character encoding and timezone of the current database connection."		^ converter ifNil: [ converter := P3Converter new ]! !!P3Client methodsFor: 'accessing'!serverEncoding	"Return the name of the encoder/decoder used by the server for this session/connection.	This is determined automatically from the client_encoding property of the server.	One way to set the default at the database level is with the SQL command	ALTER DATABASE <mydb> SET client_encoding TO 'UTF8' "		self ensureConnected.	^ self converter encoder identifier! !!P3Client methodsFor: 'accessing'!host	"Return the host name I (want to) connect to.	The default is localhost."	^ settings at: #host ifAbsentPut: [ 'localhost' ]! !!P3Client methodsFor: 'accessing'!serverVersion	"Return the version string of the PostgreSQL server"		self ensureConnected.	^ properties 		at: 'server_version' 		ifAbsent: [ (self query: 'SHOW server_version') firstFieldOfFirstRecord ]! !!P3Client methodsFor: 'accessing'!session		"Returns the current session identifier (backend process id) if connected"		self isConnected ifFalse: [ session := nil ].		^ session! !!P3Client methodsFor: 'accessing'!queryEncoding	"An alias used by PharoDatabaseAccessor, kept for compatibility"		^ self serverEncoding! !!P3Client methodsFor: 'accessing'!serverTimezone	"Return the name of the timezone used by the server for this session/connection.	This is determined automatically from the TimeZone property of the server.	One way to set the default at the database level is with the SQL command	ALTER DATABASE <mydb> SET timezone TO 'UTC' "		self ensureConnected.	^ self converter timezone id! !!P3Client methodsFor: 'accessing'!port	"Return the port I (want to) connect to.	The default is 5432."	^ settings at: #port ifAbsentPut: [ 5432 ]! !!P3Client methodsFor: 'accessing'!timeout	"Return the timeout in seconds I (want to) use, the default being 10 seconds."		^ settings at: #timeout ifAbsentPut: [ 10 ]! !!P3Client methodsFor: 'accessing'!connection	"Return the network connection I am using.	When I am not connected, return nil."		^ connection! !!P3Client methodsFor: 'accessing'!url	"Return my connection URL"		^ ZnUrl new		scheme: #psql;		host: self host;		port: self port;		username: self user;		password: self password;		addPathSegments: (self database ifNotNil: [ { self database } ] ifNil: [ #() ]);		yourself! !!P3Client methodsFor: 'accessing'!user	"Return the user of my database connection.	For the default, nil is used."	^ settings at: #user ifAbsent: [ nil ]! !!P3Client methodsFor: 'accessing'!password	"Return the password  of my database connection.	For no password, nil is used."	^ settings at: #password ifAbsent: [ nil ]! !!P3Client methodsFor: 'private'!clearSession	session := nil! !!P3Client methodsFor: 'private'!converter: anObject	converter := anObject! !!P3Client methodsFor: 'private'!processDataRowUsing: description	| count record readStream |	readStream := message readStream.	count := readStream uint16.	record := Array new: count.	1 to: count do: [ :index | | size |		size := readStream uint32.		size = 16rFFFFFFFF			ifFalse: [ | object |				object := (description at: index) convert: readStream length: size using: converter.				record at: index put: object ] ].	^ record! !!P3Client methodsFor: 'private'!clearSSL	settings removeKey: #ssl ifAbsent: [ ]! !!P3Client methodsFor: 'private'!processParameterStatus: payload	"Do not yet use the converter since it is not yet initialized"		| key value |		key := self converter asciiCStringFrom: payload.	value := self converter asciiCStringFrom: payload.			properties at: key put: value! !!P3Client methodsFor: 'private'!asCString: string	| bytes |	bytes := ByteArray new: string size + 1.	"implicit cheap ASCII conversion"	bytes replaceFrom: 1 to: string size with: string startingAt: 1. 	"last byte is 0"	^ bytes! !!P3Client methodsFor: 'private'!ensureOpen	connection ifNil: [ self open ]! !!P3Client methodsFor: 'private'!processParameterDescription: payload	| count |	count := payload uint16.	^ Array new: count streamContents: [ :out |			count timesRepeat: [ 				out nextPut: (P3ParameterDescription new					typeOid: payload int32;					yourself) ] ]! !!P3Client methodsFor: 'private'!newMessageBuilder	^ P3MessageBuilder newWithEncoder: self converter encoder! !!P3Client methodsFor: 'private'!ensureConnected	self isConnected		ifFalse: [ 			self isSSL				ifTrue: [ self connectSSL ]				ifFalse: [ self connect ] ]! !!P3Client methodsFor: 'private'!processRowDescription: payload	| count |	count := payload uint16.	^ Array new: count streamContents: [ :out |			count timesRepeat: [ 				out nextPut: (P3RowFieldDescription new					fieldName: (self converter encodedCStringFrom: payload);					tableOid: payload uint32;					attributeNumber: payload uint16;					typeOid: payload uint32;					typeSize: payload uint16;					typeModifier: payload uint32;					format: payload uint16;					yourself) ] ]! !!P3Client methodsFor: 'private'!setSSL	settings at: #ssl put: true! !!P3Client methodsFor: 'private'!forgetPreparedStatementNamed: name	properties 		at: 'prepared_statements' 		ifPresent: [ :preparedStatements | 			preparedStatements removeKey: name ifAbsent: [ ] ]! !!P3Client methodsFor: 'private'!initializeConverter	self converter initializeFrom: properties! !!P3Client methodsFor: 'private'!createPreparedStatementNamed: name withParameters: parameterDescriptions andFields: rowDescriptions	| preparedStatement |	preparedStatement := P3PreparedStatement 		newWith: self 		name: name 		parameters: parameterDescriptions 		fields: rowDescriptions.	(properties at: 'prepared_statements' ifAbsentPut: [ Dictionary new ])		at: name put: preparedStatement.	^ preparedStatement! !!P3Client methodsFor: 'private'!reset	self clearSession.	properties removeAll.	converter := nil! !!P3Client methodsFor: 'private'!processBackendKeyData: payload	session := payload uint32.	properties at: 'backend_process_id' put: session.	properties at: 'backend_secret_key' put: payload uint32! !!P3Client methodsFor: 'private'!setConnected	settings at: #connected put: true! !!P3Client methodsFor: 'protocol'!runQueryResult	| result |	result := P3Result new.	self readMessage tag = $T		ifTrue: [ result descriptions: (self processRowDescription: message readStream) ].	message tag = $C ifFalse: [ 		result data: (Array streamContents: [ :out |			[ self readMessage tag = $C ] whileFalse: [ 				self assert: message tag = $D.				out nextPut: (self processDataRowUsing: result descriptions) ] ]) ].	[		result addResult: (self converter asciiCStringFrom: message readStream).		self readMessage tag = $Z ] whileFalse.	^ result! !!P3Client methodsFor: 'protocol'!runExtendedQueryResults: fieldDescriptions		| results |	self readMessage.	results := Array streamContents: [ :out |		[			out nextPut: (self runExtendedQueryResult: fieldDescriptions).			self readMessage tag = $Z ] whileFalse ].		^ results! !!P3Client methodsFor: 'protocol'!runAuthentication	[	self readMessageCloseAfterError tag = $R		ifTrue: [ | authenticationCode salt |			authenticationCode := message readStream next: 4.			authenticationCode = #[ 0 0 0 0 ] "AuthenticationOk"				ifTrue: [ ^ self ].			authenticationCode = #[ 0 0 0 3 ] "AuthenticationCleartextPassword"				ifTrue: [ self writeMessage: self clearTextPasswordMessage tag: $p ].			authenticationCode = #[ 0 0 0 5 ] "AuthenticationMD5Password"				ifTrue: [					salt := message readStream next: 4.					self writeMessage: (self md5PasswordMessage: salt) tag: $p ] ]		ifFalse: [ 			^ P3Error unexpectedMessageDuringAuthentication signal ] ] repeat! !!P3Client methodsFor: 'protocol'!upgradeToSSL	| reply |	reply := connection next asCharacter.	reply = $S		ifTrue: [ 			connection := ZdcSecureSocketStream on: connection socket.			connection connect ]		ifFalse: [ 			P3Error postgreSQLServerDidNotHonorSSLConnectionRequest signal ]! !!P3Client methodsFor: 'protocol'!runStartup	session := 999999 atRandom. "Sometimes $K is not sent and we need a nonNil session"	[	self readMessageCloseAfterError tag = $Z		ifTrue: [ ^ self ].	message tag = $S		ifTrue: [ self processParameterStatus: message readStream ]		ifFalse: [  			message tag = $K				ifTrue: [ self processBackendKeyData: message readStream ]				ifFalse: [ ^ P3Error unexpectedMessageDuringStartup signal ] ] ] repeat! !!P3Client methodsFor: 'protocol'!runExtendedQueryResult: descriptions	"Read DataRow ($D) messages until either a CommandComplete ($C) or PortalSuspended ($s) message is received."	| rows |	"Check for BindComplete message"	message tag = $2		ifFalse: [ ^ P3Error bindCompleteExpected signal ].	self readMessage.	rows := Array streamContents: [ :out |		[ 'Cs' includes: message tag ] whileFalse: [ 			self assert: message tag = $D.			out nextPut: (self processDataRowUsing: descriptions).			self readMessage ] ].		^ P3Result descriptions: descriptions			rows: rows 			message: (self converter asciiCStringFrom: message readStream)! !!P3Client methodsFor: 'initialize-release'!close	"Cleanly close my connection with the server"	connection		ifNotNil: [ 			[ 				self writeMessage: #[] tag: $X. 				connection close ] on: Error do: [  ].				self clearSession.			connection := nil ]! !!P3Client methodsFor: 'initialize-release'!open	"Open my connection with the server (do not yet #connect)"		self close.	connection := ZdcSocketStream openConnectionToHostNamed: self host port: self port.	connection timeout: self timeout.	message := P3MessageBuffer new! !!P3Client methodsFor: 'initialize-release'!database: string	"Set the name of the database to connect to.	Set to nil or do not set to use the default."		settings at: #database put: string! !!P3Client methodsFor: 'initialize-release'!url: stringOrUrl	"Set my connection settings from stringOrUrl according to the format	psql://username:password@localhost:5432/databasename 	with the minimum being psql://user@localhost"		| url |	url := stringOrUrl asUrl.	self assert: url scheme = #psql.	self		host: url host;		port: (url portIfAbsent: [ 5432 ]);		user: url username;		password: url password;		database: url firstPathSegment ! !!P3Client methodsFor: 'initialize-release'!password: string	"Set the password to use when connecting.	Set to nil or don't set to use no password."	settings at: #password put: string! !!P3Client methodsFor: 'initialize-release'!user: string	"Set the user to use when connecting.	Set to nil or don't set to use the default."		settings at: #user put: string! !!P3Client methodsFor: 'initialize-release'!host: string	"Set the name of the host to connect to.	If not set, defaults to localhost."		settings at: #host put: string! !!P3Client methodsFor: 'initialize-release'!initialize	super initialize.		settings := IdentityDictionary new.	properties := Dictionary new.! !!P3Client methodsFor: 'initialize-release'!timeout: seconds	settings at: #timeout put: seconds! !!P3Client methodsFor: 'initialize-release'!port: integer	"Set the port to connect to.	If not set, defaults to 5432."		settings at: #port put: integer! !!P3Client methodsFor: 'public'!prepare: query named: queryName	"Create and return an instance of P3PreparedStatement by parsing query, 	which can contain one or more placeholders, once. Later the prepared statement can be executed 	multiple times by providing an array with a value for each placeholder. 	When no longer needed, the prepared statement should be closed. See P3PreparedStatement.	Each prepared statement must have a unique name. Note that in a standard Postgres installation 	only the first 63 characters of queryName are significant."	| parameterDescriptions rowDescriptions |	self 		ensureConnected;		writeParseMessage: query name: queryName types: #();		writeDescribeMessage: queryName type: $S;		writeSyncMessage.	self readMessage tag = $1		ifFalse: [ ^ P3Error parseCompleteExpected signal ].	self readMessage.	message tag = $t		ifTrue: [ parameterDescriptions := self processParameterDescription: message readStream ]		ifFalse: [ 			parameterDescriptions := #().			message tag = $n 				ifFalse: [ P3Error noDataExpected signal ] ].	self readMessage.	message tag = $T		ifTrue: [ rowDescriptions := self processRowDescription: message readStream ]		ifFalse: [ 			rowDescriptions := #().			message tag = $n				ifFalse: [ P3Error noDataExpected signal ] ].	self readMessage tag = $Z		ifFalse: [ ^ P3Error readyForQueryExpected signal ].	^ self 		createPreparedStatementNamed: queryName 		withParameters: parameterDescriptions 		andFields: rowDescriptions! !!P3Client methodsFor: 'public'!connectSSL	"Connect me to a PostgreSQL database over an encrypted SSL connection. 	Run the authentication and startup protocols. Configure the session."		self 		ensureOpen;	 	writeMessage: self sslRequestMessage;	 	upgradeToSSL;		connect;	 	setSSL! !!P3Client methodsFor: 'public'!connect	"Connect me to a PostgreSQL database. 	Run the authentication and startup protocols. Configure the session."		self 		ensureOpen;		writeMessage: self startupMessage;		reset;		runAuthentication;		runStartup;		initializeConverter;	 	clearSSL! !!P3Client methodsFor: 'public'!format: anSQLTemplateString	"Create and return a P3FormattedStatement based on anSQLTemplateString and bound to me.	The template contains numbered placeholders, $1, $2, etc, that are filled with concrete	arguments when the statement is executed. 	This should be safer and more correct than building a query manually."		^ P3FormattedStatement new		client: self;		sql: anSQLTemplateString;		yourself! !!P3Client methodsFor: 'public'!query: query	"Execute an SQL query against PostgreSQL. Return a P3Result object containing result(s), column descriptions and data.	Result(s) is a string (collection of strings for multiple embedded queries) indicating successful execution.	Descriptions is a collection of row field description objects, if any.	Data is a collection of rows with fully converted field values as objects, if any."	^ self 		ensureConnected;		writeQueryMessage: query;		runQueryResult! !!P3Client methodsFor: 'public'!execute: query	"Execute an SQL query against PostgreSQL, assuming no rows will be returned.	Result is a string (collection of strings for multiple embedded queries) indicating successful execution.	This is an alias for #query returning just the command result."		| result |	result := self query: query.	^ result results! !!P3Client methodsFor: 'public'!prepare: query	"Create a P3PreparedStatement with a default name derived from the query string. 	Only the first 63 characters of the name are significant. For longer queries try	to make a unique name by using the hash value of the query string."	| name |		name := query.	name size > 63		ifTrue: [ 			| hashString |			hashString := name hash printStringHex.			name := (name copyFrom: 1 to: 62 - hashString size), '_', hashString ].			^ self prepare: query named: name! !!P3Client methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(.	stream print: self url.	self session ifNotNil: [ stream space; print: session ].	stream nextPut: $)! !!P3Client methodsFor: 'testing'!isConnected	"Return true when my connection is in working order (from my end)"	^ connection notNil and: [ 			connection isConnected and: [ 				session notNil 			] 		]! !!P3Client methodsFor: 'testing'!isSSL	"Return true if my current connection is SSL encrypted"		^ settings at: #ssl ifAbsent: [ false ]! !!P3Client methodsFor: 'testing'!isWorking	"Do a trivial query to confirm that I can interact with the server.	Return true if successful"		| n result |	n := 999 atRandom.	result := self query: ('SELECT {1} AS N' format: { n }).	^ result result = 'SELECT 1' and: [ result firstFieldOfFirstRecord = n ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Client class	instanceVariableNames: ''!!P3Client class methodsFor: 'instance creation'!url: anUrl	^ self new url: anUrl ! !Object subclass: #P3ConnectionPool	instanceVariableNames: 'url configurator pool access'	classVariableNames: ''	package: 'P3-Core'!!P3ConnectionPool commentStamp: '' prior: 0!I am P3ConnectionPool.I offer a pool of shared PSQL connections (P3Client instances) as a resource.After configuring me with at least a url, you use me by calling #withConnection:  pool := P3ConnectionPool url: 'psql://sven@localhost'.  pool withConnection: [ :p3Client | 	  p3Client query: 'SELECT table_name FROM information_schema.tables' ].  pool close.When a connection is in use, it is not part of the pool.When a connection is returned/released to the pool, it becomes available for reuse.The pool's size is the number of open connection ready to be reused.The pool's capacity is the maximum number of connection that will be pooled.Excess connections will be closed when they are returned/released to the pool.New connections are created as needed.You can set a #configurator to further initialize new connections.You can use #warmUp or #warmUp: to precreate a number of connections.When an error occurs, the connection should not be reused and be closed by the caller.!!P3ConnectionPool methodsFor: 'public'!releaseConnection: connection	"Return connection (a P3Client) to the pool.	If the pool is at its capacity, close it.	After this, the caller can no longer use connection."		access critical: [  		pool size < pool capacity			ifTrue: [ pool addLast: connection ]			ifFalse: [ connection close ] ]! !!P3ConnectionPool methodsFor: 'public'!warmUp	"Warm up the receiver to its full capacity.	This will create all pooled connections at once."		self warmUp: self capacity! !!P3ConnectionPool methodsFor: 'public'!warmUp: numberOfConnections	"Warm up the pool to numberOfConnections.	Effectively creating that many connections at once"		| connections |	connections := Array streamContents: [ :out |		numberOfConnections timesRepeat: [ 			out nextPut: self acquireConnection ] ].	connections do: [ :each | self releaseConnection: each ]! !!P3ConnectionPool methodsFor: 'public'!withConnection: oneArgumentBlock	"Execute oneArgumentBlock with a connection (P3Client) as argument,	acquiring it from the pool and releasing it to the pool when done,	unless an error occurs (in which case the caller should close)."		| connection result error |	connection := self acquireConnection.	error := result := nil.	[ [ result := oneArgumentBlock value: connection ] 			on: Error 			do: [ :exception | error := exception. error pass ] ] 		ensure: [ error ifNil: [ self releaseConnection: connection ] ].	^ result! !!P3ConnectionPool methodsFor: 'public'!acquireConnection	"Return a connection (P3Client) from the pool or create a new one.	While in use the connection (P3Client) is removed from the pool."		^ access critical: [ 		pool			ifEmpty: [ self makeP3Client ] 			ifNotEmpty: [ pool removeLast ] ]! !!P3ConnectionPool methodsFor: 'accessing'!url	^ url! !!P3ConnectionPool methodsFor: 'accessing'!capacity	^ pool capacity ! !!P3ConnectionPool methodsFor: 'accessing'!size	^ pool size! !!P3ConnectionPool methodsFor: 'initialization'!initialize	super initialize.	access := Mutex new.	pool := OrderedCollection new: 10.	configurator := [ :p3Client | self assert: p3Client isWorking ]! !!P3ConnectionPool methodsFor: 'initialization'!configurator: oneArgumentBlock	"Set oneArgumentBlock to be my configurator.	This is code that will be executed once on each newly created connection (P3Client).	The default configuration asserts #isWorking on the argument"		configurator := oneArgumentBlock ! !!P3ConnectionPool methodsFor: 'initialization'!size: capacity	"Size me to capacity: the maximum number of connections (P3Clients) that I will hold"		pool := OrderedCollection new: capacity! !!P3ConnectionPool methodsFor: 'initialization'!close	"Close all pooled connections and remove them"		pool do: [ :each | each close ].	pool removeAll! !!P3ConnectionPool methodsFor: 'initialization'!url: aPsqlUrl	"Set the P3Client url"		url := aPsqlUrl ! !!P3ConnectionPool methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream 		nextPut: $(; 		print: self url; space; 		print: self size; nextPut: $/; print: self capacity; 		nextPut: $)! !!P3ConnectionPool methodsFor: 'private'!makeP3Client	| p3Client |	p3Client := P3Client url: url.	configurator ifNotNil: [ configurator value: p3Client ].	^ p3Client! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3ConnectionPool class	instanceVariableNames: ''!!P3ConnectionPool class methodsFor: 'instance creation'!url: anUrl	^ self new url: anUrl! !Error subclass: #P3Error	instanceVariableNames: 'info'	classVariableNames: ''	package: 'P3-Core'!!P3Error commentStamp: '' prior: 0!I am P3Error.I get signalled when something goes wrong in using P3Client, either an error inside the driver itself, or an error signalled by the PostgreSQL database backend server.I should always have a unique code and a message.Use #isLocal to distinguish between an error inside the driver itself, or an error signalled by the PostgreSQL database backend server.Reference https://www.postgresql.org/docs/9.6/errcodes-appendix.html!!P3Error methodsFor: 'accessing'!description	"Return a textual description of the exception."	^ String streamContents: [ :stream |		stream << self class name.		self isLocal 			ifFalse: [ stream space; << 'PostgreSQL' ].		self messageText isEmptyOrNil			ifFalse: [ stream space; << self messageText ] ]! !!P3Error methodsFor: 'accessing'!code	"Return my unique, locale independent, 5 character string code.	The first 2 characters are called the class.	The special P3 class groups errors that were generated locally,	as opposed to error generated by the PostgreSQL server"		^ self info at: $C ifAbsent: [ nil ]! !!P3Error methodsFor: 'accessing'!messageText	^ messageText ifNil: [ messageText := self message ]! !!P3Error methodsFor: 'accessing'!message	"Return my user oriented error message string.	This could be locale dependent.	My messageText gets initialized from this string"	^ self info at: $M ifAbsent: [ '' ]! !!P3Error methodsFor: 'accessing'!info: anObject	info := anObject! !!P3Error methodsFor: 'accessing'!info	"An info dictionary contains the fields as described in 	https://www.postgresql.org/docs/9.6/protocol-error-fields.html"	^ info ifNil: [ info := Dictionary new ]! !!P3Error methodsFor: 'testing'!isLocal	"Return true when I represent an error inside P3 itself,	as opposed to an error generted by the PostgreSQL server"		^ self code 		ifNil: [ true "if there is no code, we might have been initialized directly" ] 		ifNotNil: [ :code | code beginsWith: 'P3' ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Error class	instanceVariableNames: ''!!P3Error class methodsFor: 'accessing'!unexpectedMessageDuringAuthentication	^ self new 		info: { $C->'P3020'. $M->'Unexpected message during authentication' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!parseCompleteExpected	^ self new 		info: { $C->'P3002'. $M->'ParseComplete message expected' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!passwordRequired	^ self new 		info: { $C->'P3010'. $M->'Password required' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!closeCompleteExpected	^ self new 		info: { $C->'P3005'. $M->'CloseComplete message expected' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!unexpectedMessageDuringStartup	^ self new 		info: { $C->'P3021'. $M->'Unexpected message during startup' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!readyForQueryExpected	^ self new 		info: { $C->'P3003'. $M->'ReadyForQuery message expected' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!noDataExpected	^ self new 		info: { $C->'P3001'. $M->'NoData message expected' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!bindCompleteExpected	^ self new 		info: { $C->'P3004'. $M->'BindComplete message expected' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!postgreSQLServerDidNotHonorSSLConnectionRequest	^ self new 		info: { $C->'P3040'. $M->'PostgreSQL server did not honor SSL connection request' } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!parsingFailed: detail	^ self new 		info: { $C->'P3031'. $M->('Parsing failed "{1}"' format: { detail }) } asDictionary; 		yourself! !!P3Error class methodsFor: 'accessing'!cannotConvertTypeOid: typeOid	^ self new 		info: { $C->'P3030'. $M->('Cannot convert type with OID {1}' format: { typeOid }) } asDictionary; 		yourself! !Object subclass: #P3FormattedStatement	instanceVariableNames: 'client sql'	classVariableNames: ''	package: 'P3-Core'!!P3FormattedStatement commentStamp: '' prior: 0!I am P3FormattedStatement, an SQL template with placeholders that, together with arguments, can be executed.I am a tool to safely and more easily create SQL statements and queries that contain arguments. I know the correct textual representation of a set of primitive types. I do proper string escaping.Since I know the client that created me, I can be executed autonomously.You create instances of me by sending #format: to a P3Client instance.For example,	statement := client format: 'SELECT name, enabled FROM table1 WHERE id >= $1 ORDER BY id'.	result := statement query: #( 345 ).in the above 345 will be bound to (and replace) $1 in the SQL template.The syntax that I use ($n) and my public API is mostly polymorphic with P3PreparedStatement. The difference is that I do simple string processing on the client without any interaction with the server.!!P3FormattedStatement methodsFor: 'public'!executeBatch: argumentsCollection	"Bind each set of arguments from the argumentsCollection given	to the placeholders in my SQL template and execute this statement using my client, 	returning the collection of results"	^ argumentsCollection collect: [ :each | self execute: each ]! !!P3FormattedStatement methodsFor: 'public'!queryAll: argumentsCollection	"Bind each set of arguments from the argumentsCollection given	to the placeholders in my SQL template and execute this query using my client, 	returning the collection of results"	^ argumentsCollection collect: [ :each | self query: each ]! !!P3FormattedStatement methodsFor: 'public'!close! !!P3FormattedStatement methodsFor: 'public'!query: arguments	"Bind the arguments given to the placeholders in my SQL template and	execute this query using my client, returning the result"		^ client query: (self bind: arguments)! !!P3FormattedStatement methodsFor: 'public'!execute: arguments	"Bind the arguments given to the placeholders in my SQL template and	execute this statement using my client, returning the result"	^ client execute: (self bind: arguments)! !!P3FormattedStatement methodsFor: 'private'!bind: arguments	"Build and return the actual SQL statement by splicing in the arguments for all placeholders in the template"		^ String streamContents: [ :out | | readStream |			readStream := sql readStream.			[ readStream atEnd ] whileFalse: [ | char |				(char := readStream next) = $$					ifTrue: [ | index argument |						index := Integer readFrom: readStream.						argument := arguments at: index.						argument p3PrintUsing: self on: out ]					ifFalse: [ out nextPut: char ] ] ]! !!P3FormattedStatement methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; << sql; nextPut: $)! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printDateAndTime: dateAndTime on: stream	"Use ISO 8601 YYYY-MM-DDThh:mm:ss.s+ZZ:zz"		stream nextPut: $'.	dateAndTime printOn: stream.	stream nextPut: $' ! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printScaledDecimal: scaledDecimal on: stream	"For ScaledDecimals, use a regular floating point like representation"		scaledDecimal 		printOn: stream 		showingDecimalPlaces: scaledDecimal scale! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printGeometricObject: geometricObject on: stream	"Delegate to P3GeometricObject that knows how to print itself in typed quoted PSQL text format"		geometricObject printPsqlOn: stream! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printTime: time on: stream	"Use ISO 8601 hh:mm:ss"		stream nextPut: $'.	time print24: true on: stream.	stream nextPut: $'! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printBitString: bitString on: stream	"Use the B'0101' syntax for bit strings"		stream nextPut: $B; nextPut: $'; print: bitString; nextPut: $'! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printObject: object on: stream	"In general, just use the standard print string representation"		object printOn: stream ! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printInterval: interval on: stream	"Delegate partially to P3Interval that knows how to print itself in postgresql style"		stream nextPutAll: #interval; space; nextPut: $'; print: interval; nextPut: $'! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printValuesArray: valuesArray on: stream	| first |	first := true.	stream nextPutAll: #array.	stream nextPut: $[.	valuesArray do: [ :each |		first ifTrue: [ first := false ] ifFalse: [ stream nextPut: $, ].		each p3PrintUsing: self on: stream ].	stream nextPut: $]! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printString: string on: stream	"For strings use single quotes and the doubling of single quotes when they are part of the string"		stream nextPut: $'.	string do: [ :each |		each = $' ifTrue: [ stream nextPut: $' ].		stream nextPut: each ].	stream nextPut: $'! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printNullOn: stream	"nil becomes NULL"		stream nextPutAll: 'NULL'! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printDate: date on: stream	"Use ISO 8601 YYYY-MM-DD"		stream nextPut: $'.	date printOn: stream format: #(3 2 1 $- 1 1 2).	stream nextPut: $'! !!P3FormattedStatement methodsFor: 'printing-dispatched'!printByteArray: byteArray on: stream	"Use the bytea Hex Format for bytes (ByteArray),	as in '\xDEADBEEF'"		| hex |	stream nextPutAll: '''\x'.	hex := '0123456789ABCDEF'.	byteArray do: [ :byte | 		stream 			nextPut: (hex at: (byte bitShift: -4) + 1);			nextPut: (hex at: (byte bitAnd: 15) + 1) ].	stream nextPut: $'! !!P3FormattedStatement methodsFor: 'initialization'!client: aP3Client	client := aP3Client! !!P3FormattedStatement methodsFor: 'initialization'!sql: anSQLTemplateString	sql := anSQLTemplateString ! !Notification subclass: #P3Notification	instanceVariableNames: 'info'	classVariableNames: ''	package: 'P3-Core'!!P3Notification commentStamp: '' prior: 0!I am P3Notification.I get signalled when the PostgreSQL database backend server signals a notification, a kind of harmless warning.!!P3Notification methodsFor: 'accessing'!description	"Return a textual description of the exception."	^ String streamContents: [ :stream |		stream << self class name << ' PostgreSQL'.		self messageText isEmptyOrNil			ifFalse: [ stream space; << self messageText ] ]! !!P3Notification methodsFor: 'accessing'!code	"Return my unique, locale independent, 5 character string code."		^ self info at: $C ifAbsent: [ nil ]! !!P3Notification methodsFor: 'accessing'!messageText	^ messageText ifNil: [ messageText := self message ]! !!P3Notification methodsFor: 'accessing'!message	"Return my user oriented error message string.	This could be locale dependent.	My messageText gets initialized from this string"	^ self info at: $M ifAbsent: [ '' ]! !!P3Notification methodsFor: 'accessing'!info: anObject	info := anObject! !!P3Notification methodsFor: 'accessing'!info	^ info ifNil: [ info := Dictionary new ]! !Object subclass: #P3PreparedStatement	instanceVariableNames: 'client name paramDescriptions fieldDescriptions'	classVariableNames: ''	package: 'P3-Core'!!P3PreparedStatement commentStamp: '' prior: 0!I am P3PreparedStatement. Use me if you need to execute a query multiple times.Create an instance of me via P3Client>>#prepare: The argument to this method is a query string that can contain one or more placeholders. When executing the statement an array should be provided with a value for each placeholder.Examples:Prepare an insert statement and execute it two times with different parameters:	statement := client prepare: 'INSERT INTO table1 (id, name, enabled) VALUES ($1,$2,$3)'.	result := statement execute: #( 123 'Hello World' true ).	result := statement execute: #( 45 'Greetings' false ).It's also possible to execute the two inserts in a single network roundtrip:	statement := client prepare: 'INSERT INTO table1 (id, name, enabled) VALUES ($1,$2,$3)'.	results := statement executeBatch: #( 		( 123 'Hello World' true )		( 45 'Greetings' false ) ).Select query:	statement := client prepare: 'SELECT name, enabled FROM table1 WHERE id = $1'.	result := statement query: #( 123 ).When I'm no longer needed I should be closed so that the PostgreSQL server side resources for this prepared statemed are freed.See also https://en.wikipedia.org/wiki/Prepared_statementA prepared statement can be more efficient, especially if it is used multiple times. Prepared statements are also resilient against SQL injection attacks. On the server, prepared statements are bound to the current session.My API and the syntax that I use ($n) is mostly polymorphic with P3FormattedStatement. The difference is that I do much more than textual processing: my SQL template is actually parsed on the server, checking the syntax and partially planning the execution, during the actual execution phase, just the concrete argument values are transferred, taking advantage of some of the work that has already been done on the server. !!P3PreparedStatement methodsFor: 'input/output'!writeCloseMessage: aName type: aChar	| msgBuilder |	msgBuilder := client newMessageBuilder.	msgBuilder 		nextPutByte: aChar asInteger;		nextPutString: aName.	client writeMessageNoFlush: msgBuilder asBytes tag: $C! !!P3PreparedStatement methodsFor: 'input/output'!writeDescribeMessage: aName type: aChar	"Type $S to describe a prepared statement; or $P to describe a portal."	| msgBuilder |	msgBuilder := client newMessageBuilder.	msgBuilder		nextPutByte: aChar asInteger;		nextPutString: aName.	client writeMessageNoFlush: msgBuilder asBytes tag: $D! !!P3PreparedStatement methodsFor: 'input/output'!writeFlushMessage	client writeMessage: #[] tag: $H! !!P3PreparedStatement methodsFor: 'input/output'!bindStrings: inputValues	| msgBuilder |	msgBuilder := client newMessageBuilder.	msgBuilder		nextPutString: '';		nextPutString: name;		nextPutInt16: 0;		nextPutInt16: inputValues size.	inputValues		with: paramDescriptions		do: [ :eachValue :paramDescription | 			eachValue				ifNil: [ msgBuilder nextPutNullParameter ]				ifNotNil: [ msgBuilder nextPutParameterAsText: eachValue description: paramDescription ]			].	msgBuilder nextPutInt16: 0.	"All result columns use the text format"	client writeMessageNoFlush: msgBuilder asBytes tag: $B! !!P3PreparedStatement methodsFor: 'input/output'!writeExecuteMessage: rowLimit	| msgBuilder |	msgBuilder := client newMessageBuilder.	msgBuilder		nextPutString: '';		nextPutInt32: rowLimit.	client writeMessageNoFlush: msgBuilder asBytes tag: $E! !!P3PreparedStatement methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(; << name; nextPut: $)! !!P3PreparedStatement methodsFor: 'accessing'!converter 	^ client converter! !!P3PreparedStatement methodsFor: 'accessing'!fieldDescriptions	^ fieldDescriptions! !!P3PreparedStatement methodsFor: 'accessing'!paramCount	^ paramDescriptions size! !!P3PreparedStatement methodsFor: 'accessing'!name	^ name! !!P3PreparedStatement methodsFor: 'accessing'!fieldCount	^ fieldDescriptions size! !!P3PreparedStatement methodsFor: 'accessing'!paramDescriptions	^ paramDescriptions! !!P3PreparedStatement methodsFor: 'initialization'!initializeWith: aClient name: aString parameters: aParamDescriptions fields: aRowFieldDescriptions	client := aClient.	name := aString.	paramDescriptions := aParamDescriptions.	fieldDescriptions := aRowFieldDescriptions! !!P3PreparedStatement methodsFor: 'public'!executeBatch: inputRows	"Execute this SQL query mutiple (inputRow size) times in a single network roundtrip.	Assume no rows will be returned."	inputRows isEmpty		ifTrue: [ ^ #() ].	inputRows do: [ :eachRow |		self bindStrings: eachRow.		self writeExecuteMessage: 0 ].	client writeSyncMessage.		^ (client runExtendedQueryResults: fieldDescriptions) collect: [ :each | each result ]! !!P3PreparedStatement methodsFor: 'public'!queryAll: inputRows	"Execute this SQL query multiple times.	Answer a collection of P3Result objects with the field descriptions and rows."	inputRows isEmpty		ifTrue: [ ^ #() ].	inputRows do: [ :eachRow |		self bindStrings: eachRow.		self writeExecuteMessage: 0 ].	client writeSyncMessage.		^ client runExtendedQueryResults: fieldDescriptions! !!P3PreparedStatement methodsFor: 'public'!close	"Close this query and release server side resources."	client ifNil: [ ^ self ].	self writeCloseMessage: name type: $S.	self writeFlushMessage.			"Check for CloseComplete message"	client readMessage tag = $3		ifFalse: [ P3Error closeCompleteExpected signal ].			"This prepared statement can no longer be used."	client forgetPreparedStatementNamed: name.	client := nil! !!P3PreparedStatement methodsFor: 'public'!query: inputRow	"Execute this SQL query with inputRow as the ordered collection of parameters.	Answer a P3Result object with the field descriptions and rows."	self bindStrings: inputRow.	self writeExecuteMessage: 0.	client writeSyncMessage.		^ (client runExtendedQueryResults: fieldDescriptions) first! !!P3PreparedStatement methodsFor: 'public'!execute: inputRow	"Execute this SQL query with inputRow as the ordered collection of parameters.	Assume no rows will be returned."	self bindStrings: inputRow.	self writeExecuteMessage: 0.	client writeSyncMessage.		^ (client runExtendedQueryResults: fieldDescriptions) first result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3PreparedStatement class	instanceVariableNames: ''!!P3PreparedStatement class methodsFor: 'instance creation'!newWith: aClient name: aString parameters: paramDescriptions fields: rowDescriptions	^ self new initializeWith: aClient name: aString parameters: paramDescriptions fields: rowDescriptions! !Object subclass: #P3Result	instanceVariableNames: 'results descriptions data'	classVariableNames: ''	package: 'P3-Core'!!P3Result commentStamp: '' prior: 0!I am P3Result, I encapsulate the result from a PostgreSQL query.I hold 3 things:- results -  the command completion tags, a String (singular if there was only one query) or a collection of Strings (if there were multiple queries) in the form of 'SELECT 100'- descriptions - a collection of P3RowFieldDescription objects (one for each column, nil if there is no data)- data - a collection of records with each field value converted to objects, nil if there is no dataEven if there are multiple queries, there can only be one stream of records. Most of the time, results is singular.!!P3Result methodsFor: 'convenience'!columns	"Return the P3RowFieldDescriptions of the columns of the data that I hold"	^ descriptions! !!P3Result methodsFor: 'convenience'!firstColumnData	"Return a flat collection of the data in the first column that I hold"		^ data collect: #first! !!P3Result methodsFor: 'convenience'!columnNames	"Return the names of the columns of the data that I hold"		^ descriptions collect: #fieldName! !!P3Result methodsFor: 'convenience'!firstFieldOfFirstRecord	"Return the value of the first field of the first record that I hold"		^ self firstRecord first! !!P3Result methodsFor: 'convenience'!recordsAsDictionaries	"Return the data that I hold as a collection where each record 	is represented by a Dictionary whose keys are the column names.	This more verbose representation can be more user friendly."		^ self records collect: [ :record |		| dictionary |		dictionary := Dictionary new.		self descriptions withIndexDo: [ :description :index |			dictionary at: description fieldName asSymbol put: (record at: index) ].		dictionary ]! !!P3Result methodsFor: 'convenience'!records	"Return the records that I hold, also known as my data"		^ data! !!P3Result methodsFor: 'private-accessing'!addResult: subResult	results := results		ifNil: [ subResult ]		ifNotNil: [ results isString				ifTrue: [ Array with: results with: subResult ]				ifFalse: [ results copyWith: subResult ] ]! !!P3Result methodsFor: 'private-accessing'!data: collection	data := collection! !!P3Result methodsFor: 'private-accessing'!results: stringOrCollectionOfStrings	results := stringOrCollectionOfStrings! !!P3Result methodsFor: 'private-accessing'!descriptions: collectionOfRowFieldDescriptions	descriptions := collectionOfRowFieldDescriptions! !!P3Result methodsFor: 'printing'!printOn: stream	super printOn: stream.	stream nextPut: $(.	self hasResults		ifTrue: [ stream print: results ].	self hasData		ifTrue: [ stream				space;				print: self numberOfRecords;				<< (' record' asPluralBasedOn: self numberOfRecords);				space;				print: self numberOfColumns;				<< (' colum' asPluralBasedOn: self numberOfColumns) ].	stream nextPut: $)! !!P3Result methodsFor: 'private'!rowCountFromCommandResultTag: string	string ifEmpty: [ ^ 0 ].	^ ($ split: string) last asInteger! !!P3Result methodsFor: 'accessing'!firstResult	"Return the SQL query execution result, or the first one if there are multiple results.	Among other things, the result indicates how many rows were returned or modified."		^ results isString ifTrue: [ results ] ifFalse: [ results first ]! !!P3Result methodsFor: 'accessing'!result	"Return the result.	As this is the most common case, we assume a single result."		^ self firstResult! !!P3Result methodsFor: 'accessing'!totalRowCount	"Return the total integer count of the number of record returned or modified in all results"	results ifNil: [ ^ 0 ].	^ results isString		ifTrue: [ 			self firstRowCount ]		ifFalse: [ 			results 				inject: 0 				into: [ :sum :next | sum + (self rowCountFromCommandResultTag: next) ] ]! !!P3Result methodsFor: 'accessing'!numberOfRecords	"Return the actual number of records that are in the data that I hold.	In principle this equals #rowCount"		^ self hasData ifTrue: [ self data size ] ifFalse: [ 0 ]! !!P3Result methodsFor: 'accessing'!firstRowCount	"Return the row count for the first result that I hold.	This is the integer count of the the number of records returned or modified"		^ self rowCountFromCommandResultTag: self firstResult! !!P3Result methodsFor: 'accessing'!data	"Return the data that I represent, 	an Array containing equal sized Arrays for each record in the result"		^ data! !!P3Result methodsFor: 'accessing'!rowCount	"Return the integer count of the number of records returned or modified.	If there is data, this equals #numberOfRecords"		^ self firstRowCount! !!P3Result methodsFor: 'accessing'!results	"Return the SQL query execution results, possibly a collection.	Among other things, the results indicates how many rows were returned or modified."	^ results! !!P3Result methodsFor: 'accessing'!firstRecord	"Return the first record of the result, which will be an Array"		^ self records first! !!P3Result methodsFor: 'accessing'!descriptions	"Return the P3RowFieldDescriptions of the result that I represent.	There will be one such description for each column."		^ descriptions! !!P3Result methodsFor: 'accessing'!numberOfColumns	"Return the number of columns that I hold.	Each record in my data will be of this size."		^ self hasDescriptions ifTrue: [ self descriptions size ] ifFalse: [ 0 ]! !!P3Result methodsFor: 'testing'!hasDescriptions	^ descriptions notNil! !!P3Result methodsFor: 'testing'!hasData	^ data notNil! !!P3Result methodsFor: 'testing'!hasResults	^ results notNil! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Result class	instanceVariableNames: ''!!P3Result class methodsFor: 'instance creation'!descriptions: descriptions rows: aRowArray message: aString	^ self new			descriptions: descriptions;			data: aRowArray;			results: aString;			yourself! !