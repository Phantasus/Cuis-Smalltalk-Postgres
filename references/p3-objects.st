Object subclass: #P3BitString	instanceVariableNames: 'bits'	classVariableNames: ''	package: 'P3-Objects'!!P3BitString commentStamp: '' prior: 0!I am P3BitString.Note that PSQL's B'100' is actually 2r001 in Pharo.My internal representation is an Integer.I am of the BIT VARYING type, with a flexible, as needed, length/size.!!P3BitString methodsFor: 'accessing'!bitAt: index put: value	"One based index (PSQL is zero based), value must be 0 or 1"		bits := bits bitAt: index put: value! !!P3BitString methodsFor: 'accessing'!size	^ bits = 0 ifTrue: [ 1 ] ifFalse: [ bits highBit ]! !!P3BitString methodsFor: 'accessing'!bits	^ bits! !!P3BitString methodsFor: 'accessing'!bitAt: index	"One based index (PSQL is zero based), returns 0 or 1"		^ bits bitAt: index! !!P3BitString methodsFor: 'private'!bits: integer	bits := integer! !!P3BitString methodsFor: 'printing'!printOn: stream	1 to: self size do: [ :index |		stream nextPut: (48 + (bits bitAt: index)) asCharacter ]! !!P3BitString methodsFor: 'printing'!p3PrintUsing: delegate on: stream	"Print me on stream via double dispatch on delegate.	Check the implementors of #p3PrintOn:using:"	delegate printBitString: self on: stream! !!P3BitString methodsFor: 'initialization'!initialize	super initialize.	bits := 0! !!P3BitString methodsFor: 'comparing'!= anotherBitString	self == anotherBitString ifTrue: [ ^ true ].	self class = anotherBitString class ifFalse: [ ^ false ].	^ bits = anotherBitString bits! !!P3BitString methodsFor: 'comparing'!hash	^ bits hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3BitString class	instanceVariableNames: ''!!P3BitString class methodsFor: 'instance creation'!readFrom: stream	| bits index |	bits := 0.	index := 1.	[ stream atEnd or: [ ('01' includes: stream peek) not ] ] whileFalse: [ 		bits := bits bitAt: index put: (stream next charCode - 48).		index := index + 1 ].	^ self bits: bits count: index - 1! !!P3BitString class methodsFor: 'instance creation'!one	^ self bits: 1! !!P3BitString class methodsFor: 'instance creation'!zero	^ self new! !!P3BitString class methodsFor: 'instance creation'!bits: integer	^ self new		bits: integer;		yourself! !!P3BitString class methodsFor: 'instance creation'!bits: integer count: count	^ self bits: integer! !P3BitString subclass: #P3FixedBitString	instanceVariableNames: 'size'	classVariableNames: ''	package: 'P3-Objects'!!P3FixedBitString commentStamp: '' prior: 0!I am P3FixedBitString.I am a P3BitString.I represent the BIT(N) type, with a fixed length/size.!!P3FixedBitString methodsFor: 'accessing'!bitAt: index put: value	(index between: 1 and: size)		ifFalse: [ 			SubscriptOutOfBounds				signalFor: index				lowerBound: 1				upperBound: size				in: self ].	^ super bitAt: index put: value! !!P3FixedBitString methodsFor: 'accessing'!size	^ size! !!P3FixedBitString methodsFor: 'accessing'!bitAt: index	(index between: 1 and: size)		ifFalse: [ 			SubscriptOutOfBounds				signalFor: index				lowerBound: 1				upperBound: size				in: self ].	^ super bitAt: index! !!P3FixedBitString methodsFor: 'comparing'!= anotherFixedBitString	self == anotherFixedBitString ifTrue: [ ^ true ].	self class = anotherFixedBitString class ifFalse: [ ^ false ].	^ bits = anotherFixedBitString bits and: [ size = anotherFixedBitString size ]! !!P3FixedBitString methodsFor: 'comparing'!hash	^ (super hash + size hash) hashMultiply! !!P3FixedBitString methodsFor: 'initialization'!initialize	super initialize.	size := 1! !!P3FixedBitString methodsFor: 'private'!size: numberOfBits	size := numberOfBits ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3FixedBitString class	instanceVariableNames: ''!!P3FixedBitString class methodsFor: 'instance creation'!bits: integer count: count	^ self new 		bits: integer;		size: count;		yourself! !!P3FixedBitString class methodsFor: 'instance creation'!bits: integer	^ self bits: integer count: (integer highBit max: 1)! !Object subclass: #P3GeometricObject	instanceVariableNames: ''	classVariableNames: ''	package: 'P3-Objects'!!P3GeometricObject commentStamp: '' prior: 0!I am P3GeometricObject, the abstract superclass for all PostgreSQL geometric data tyoes, representing two-dimenional spatial objects.!!P3GeometricObject methodsFor: 'printing'!printPsqlOn: stream	stream 		nextPutAll: self tag; 		space; 		nextPut: $'; 		print: self; 		nextPut: $'! !!P3GeometricObject methodsFor: 'printing'!p3PrintUsing: delegate on: stream	"Print me on stream via double dispatch on delegate.	Check the implementors of #p3PrintOn:using:"	delegate printGeometricObject: self on: stream! !!P3GeometricObject methodsFor: 'accessing'!tag	^ self class tag! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3GeometricObject class	instanceVariableNames: ''!!P3GeometricObject class methodsFor: 'accessing'!tag	self subclassResponsibility! !P3GeometricObject subclass: #P3Box	instanceVariableNames: 'upperRight lowerLeft'	classVariableNames: ''	package: 'P3-Objects'!!P3Box commentStamp: '' prior: 0!I am P3Box	(x1,y1),(x2,y2)I am a P3GeometricObjectMy internal representation is an upper right and lower left point!!P3Box methodsFor: 'comparing'!= anotherBox	self == anotherBox ifTrue: [ ^ true ].	self class = anotherBox class ifFalse: [ ^ false ].	^ upperRight = anotherBox upperRight and: [ lowerLeft = anotherBox lowerLeft ]! !!P3Box methodsFor: 'comparing'!hash	^ (upperRight hash + lowerLeft hash) hashMultiply! !!P3Box methodsFor: 'printing'!printOn: stream	upperRight printOn: stream.	stream nextPut: $,.	lowerLeft printOn: stream! !!P3Box methodsFor: 'accessing'!lowerLeft	^ lowerLeft ! !!P3Box methodsFor: 'accessing'!center	^ P3Point x: (self width / 2 + lowerLeft x) y: (self height / 2 + lowerLeft y)! !!P3Box methodsFor: 'accessing'!upperRight	^ upperRight! !!P3Box methodsFor: 'accessing'!height	^ upperRight y - lowerLeft y! !!P3Box methodsFor: 'accessing'!area	^ self width * self height! !!P3Box methodsFor: 'accessing'!width	^ upperRight x - lowerLeft x! !!P3Box methodsFor: 'private'!lowerLeft: point	lowerLeft := point! !!P3Box methodsFor: 'private'!upperRight: point	upperRight := point! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Box class	instanceVariableNames: ''!!P3Box class methodsFor: 'accessing'!tag	^ #box! !!P3Box class methodsFor: 'instance creation'!unit	^ self upperRight: P3Point unit lowerLeft: P3Point zero! !!P3Box class methodsFor: 'instance creation'!zero	^ self upperRight: P3Point zero lowerLeft: P3Point zero! !!P3Box class methodsFor: 'instance creation'!readFrom: stream	| upperRight lowerLeft |	upperRight := P3Point readFrom: stream.	(stream peekFor: $,) ifFalse: [ 			(P3Error parsingFailed: 'separator , not found') signal ].	lowerLeft := P3Point readFrom: stream.	^ self upperRight: upperRight lowerLeft: lowerLeft! !!P3Box class methodsFor: 'instance creation'!upperRight: upperRight lowerLeft: lowerLeft	^ self new		upperRight: upperRight;		lowerLeft: lowerLeft;		yourself! !P3GeometricObject subclass: #P3Circle	instanceVariableNames: 'center radius'	classVariableNames: ''	package: 'P3-Objects'!!P3Circle commentStamp: '' prior: 0!I am P3Circle	<(x,y),r>I am a P3GeometricObjectMy internal representation is a center point and a radius!!P3Circle methodsFor: 'private'!center: point	center := point! !!P3Circle methodsFor: 'private'!radius: number	radius := number! !!P3Circle methodsFor: 'printing'!printOn: stream	stream nextPut: $<.	center printOn: stream.	stream nextPut: $,.	radius printOn: stream.	stream nextPut: $>! !!P3Circle methodsFor: 'comparing'!= anotherCircle	self == anotherCircle ifTrue: [ ^ true ].	self class = anotherCircle class ifFalse: [ ^ false ].	^ center = anotherCircle center and: [ radius = anotherCircle radius ]! !!P3Circle methodsFor: 'comparing'!hash	^ (center hash hashMultiply + radius hash) hashMultiply! !!P3Circle methodsFor: 'accessing'!radius	^ radius! !!P3Circle methodsFor: 'accessing'!circumference	^ 2 * Float pi * radius! !!P3Circle methodsFor: 'accessing'!center	^ center! !!P3Circle methodsFor: 'accessing'!area	^ Float pi * radius squared ! !!P3Circle methodsFor: 'accessing'!diameter	^ radius * 2! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Circle class	instanceVariableNames: ''!!P3Circle class methodsFor: 'instance creation'!center: center radius: radius	^ self new		center: center;		radius: radius;		yourself! !!P3Circle class methodsFor: 'instance creation'!unit	^ self center: P3Point origin radius: 1 ! !!P3Circle class methodsFor: 'instance creation'!readFrom: stream	| center radius |	(stream peekFor: $<) ifFalse: [ 		(P3Error parsingFailed: 'opening < not found') signal ].	center := P3Point readFrom: stream.	(stream peekFor: $,) ifFalse: [ 		(P3Error parsingFailed: 'separating , not found') signal ].	radius := Number readFrom: stream.	(stream peekFor: $>) ifFalse: [ 		(P3Error parsingFailed: 'closing > not found') signal ].	^ self center: center radius: radius! !!P3Circle class methodsFor: 'accessing'!tag	^ #circle! !Object subclass: #P3Interval	instanceVariableNames: 'years months days hours minutes seconds'	classVariableNames: ''	package: 'P3-Objects'!!P3Interval commentStamp: '' prior: 0!I am P3Interval, a time duration (INTERVAL).I store all components separately.I support the 'postgres' default IO format.I can also print myself using the 'iso8601 with designators' format.This is currently an MVP implementation.!!P3Interval methodsFor: 'comparing'!= anotherInterval	self == anotherInterval		ifTrue: [ ^ true ].	self class = anotherInterval class		ifFalse: [ ^ false ].	^ years = anotherInterval years		and: [ months = anotherInterval months				and: [ days = anotherInterval days						and: [ hours = anotherInterval hours								and: [ minutes = anotherInterval minutes										and: [ seconds = anotherInterval seconds ] ] ] ] ]! !!P3Interval methodsFor: 'comparing'!hash	^ ((years hash + months hash + days hash) hashMultiply		+ (hours hash + minutes hash + seconds hash) hashMultiply)		hashMultiply! !!P3Interval methodsFor: 'printing'!printIso8601On: stream	stream nextPut: $P.	years = 0 ifFalse: [ 		stream print: years; nextPut: $Y ].	months = 0 ifFalse: [		stream print: months; nextPut: $M ].	days = 0 ifFalse: [		stream print: days; nextPut: $D ].	stream nextPut: $T.	hours = 0 ifFalse: [ 		stream print: hours; nextPut: $H ].	minutes = 0 ifFalse: [		stream print: minutes; nextPut: $M ].	seconds = 0 ifFalse: [		stream print: seconds; nextPut: $S ]! !!P3Interval methodsFor: 'printing'!printOn: stream	| space |	space := false.	years = 0 ifFalse: [ 		stream print: years; space.		stream nextPutAll: (years = 1 ifTrue: [ 'year' ] ifFalse: [ 'years' ]).		space := true ].	months = 0 ifFalse: [		space ifTrue: [ stream space ]. 		stream print: months; space.		stream nextPutAll: (months = 1 ifTrue: [ 'mon' ] ifFalse: [ 'mons' ]).		space := true ].	days = 0 ifFalse: [		space ifTrue: [ stream space ]. 		stream print: days; space.		stream nextPutAll: (days = 1 ifTrue: [ 'day' ] ifFalse: [ 'days' ]).		space := true ].	space ifTrue: [ stream space ].	hours printOn: stream base: 10 length: 2 padded: true.	stream nextPut: $:.	minutes printOn: stream base: 10 length: 2 padded: true.	stream nextPut: $:.	seconds < 10 ifTrue: [ stream print: 0 ].	seconds printOn: stream! !!P3Interval methodsFor: 'printing'!p3PrintUsing: delegate on: stream	"Print me on stream via double dispatch on delegate.	Check the implementors of #p3PrintOn:using:"	delegate printInterval: self on: stream! !!P3Interval methodsFor: 'accessing'!seconds: anObject	seconds := anObject! !!P3Interval methodsFor: 'accessing'!years: anObject	years := anObject! !!P3Interval methodsFor: 'accessing'!minutes	^ minutes! !!P3Interval methodsFor: 'accessing'!days	^ days! !!P3Interval methodsFor: 'accessing'!months: anObject	months := anObject! !!P3Interval methodsFor: 'accessing'!days: anObject	days := anObject! !!P3Interval methodsFor: 'accessing'!months	^ months! !!P3Interval methodsFor: 'accessing'!hours: anObject	hours := anObject! !!P3Interval methodsFor: 'accessing'!hours	^ hours! !!P3Interval methodsFor: 'accessing'!seconds	^ seconds! !!P3Interval methodsFor: 'accessing'!minutes: anObject	minutes := anObject! !!P3Interval methodsFor: 'accessing'!years	^ years! !!P3Interval methodsFor: 'initialization'!initialize	super initialize.	years := months := days := hours := minutes := seconds := 0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Interval class	instanceVariableNames: ''!!P3Interval class methodsFor: 'instance creation'!zero	^ self new! !!P3Interval class methodsFor: 'instance creation'!years: years months: months days: days hours: hours minutes: minutes seconds: seconds	^ self new		years: years;		months: months;		days: days;		hours: hours;		minutes: minutes;		seconds: seconds;		yourself! !!P3Interval class methodsFor: 'instance creation'!readFrom: stream	| years months days hours minutes seconds number word helper count |	years := months := days := hours := minutes := seconds := 0.	helper := [ :value :designator |		(designator beginsWith: 'year') ifTrue: [ years := value ].		(designator beginsWith: 'mon') ifTrue: [ months := value ].		(designator beginsWith: 'day') ifTrue: [ days := value ] ].	count := number := 0.	[ count <= 3 ] whileTrue: [		self skipSeparators: stream.		number := stream atEnd ifTrue: [ nil ] ifFalse: [ Number readFrom: stream ].		word := self readDesignator: stream.		word = ':' 			ifTrue: [ count := 4 ]			ifFalse: [ 				helper value: number value: word.		 		count := count + 1 ] ].	stream atEnd 		ifFalse: [ 			hours := number.			stream peekFor: $:.			minutes := Number readFrom: stream.			stream peekFor: $:.			seconds := Number readFrom: stream ].	^ self years: years months: months days: days hours: hours minutes: minutes seconds: seconds! !!P3Interval class methodsFor: 'private'!readDesignator: stream	self skipSeparators: stream.	^ String streamContents: [ :out |		[ stream atEnd not and: [ stream peek isLetter or: [ stream peek = $: ] ] ] 			whileTrue: [ out nextPut: stream next ] ]! !!P3Interval class methodsFor: 'private'!skipSeparators: stream	[ stream atEnd not and: [ stream peek isSeparator ] ] whileTrue: [ stream next ]! !P3GeometricObject subclass: #P3Line	instanceVariableNames: 'a b c'	classVariableNames: ''	package: 'P3-Objects'!!P3Line commentStamp: '' prior: 0!I am P3Line	{a,b,c} ax+by+c=0I am a P3GeometricObjectMy internal representation consists of my 3 coefficients, a, b and c!!P3Line methodsFor: 'private'!c: number	c := number! !!P3Line methodsFor: 'private'!a: number	a := number! !!P3Line methodsFor: 'private'!b: number	b := number! !!P3Line methodsFor: 'comparing'!= anotherLine	self == anotherLine ifTrue: [ ^ true ].	self class = anotherLine class ifFalse: [ ^ false ].	^ a = anotherLine a and: [ b = anotherLine b and: [ c = anotherLine c ] ]! !!P3Line methodsFor: 'comparing'!hash 	^ ((a hash + b hash) hashMultiply + c hash) hashMultiply ! !!P3Line methodsFor: 'comparing'!printOn: stream	stream 		nextPut: ${;		print: a;		nextPut: $,;		print: b;		nextPut: $,;		print: c;		nextPut: $}! !!P3Line methodsFor: 'accessing'!b	^ b! !!P3Line methodsFor: 'accessing'!a	^ a! !!P3Line methodsFor: 'accessing'!c	^ c! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Line class	instanceVariableNames: ''!!P3Line class methodsFor: 'accessing'!tag	^ #line! !!P3Line class methodsFor: 'instance creation'!yAxis	^ self a: 1 b: 0 c: 0! !!P3Line class methodsFor: 'instance creation'!xAxis	^ self a: 0 b: 1 c: 0! !!P3Line class methodsFor: 'instance creation'!readFrom: stream	| a b c |	(stream peekFor: ${) ifFalse: [ 		(P3Error parsingFailed: 'opening { not found') signal ].	a := Number readFrom: stream.	(stream peekFor: $,) ifFalse: [ 		(P3Error parsingFailed: 'separator , not found') signal ].	b := Number readFrom: stream.	(stream peekFor: $,) ifFalse: [ 		(P3Error parsingFailed: 'separator , not found') signal ].	c := Number readFrom: stream.	(stream peekFor: $}) ifFalse: [ 		(P3Error parsingFailed: 'closing } not found') signal ].	^ self a: a b: b c: c! !!P3Line class methodsFor: 'instance creation'!a: a b: b c: c	^ self new		a: a;		b: b;		c: c;		yourself! !P3GeometricObject subclass: #P3LineSegment	instanceVariableNames: 'start stop'	classVariableNames: ''	package: 'P3-Objects'!!P3LineSegment commentStamp: '' prior: 0!I am P3LineSegment	[(x1,y1),(x2,y2)]I am a P3GeometricObjectMy internal reperesentation is a start and stop point!!P3LineSegment methodsFor: 'private'!start: point	start := point! !!P3LineSegment methodsFor: 'private'!stop: point	stop := point! !!P3LineSegment methodsFor: 'accessing'!length	^ ((stop x - start x) squared + (stop y - start y) squared) sqrt! !!P3LineSegment methodsFor: 'accessing'!start	^ start! !!P3LineSegment methodsFor: 'accessing'!stop	^ stop! !!P3LineSegment methodsFor: 'printing'!printOn: stream	stream nextPut: $[.	start printOn: stream.	stream nextPut: $,.	stop printOn: stream.	stream nextPut: $]! !!P3LineSegment methodsFor: 'comparing'!= anotherLineSegment	self == anotherLineSegment ifTrue: [ ^ true ].	self class = anotherLineSegment class ifFalse: [ ^ false ].	^ start = anotherLineSegment start and: [ stop = anotherLineSegment stop ]! !!P3LineSegment methodsFor: 'comparing'!hash	^ (start hash + stop hash) hashMultiply! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3LineSegment class	instanceVariableNames: ''!!P3LineSegment class methodsFor: 'accessing'!tag	^ #lseg! !!P3LineSegment class methodsFor: 'instance creation'!xAxisUnit	^ self start: P3Point zero stop: (P3Point x: 1 y: 0) ! !!P3LineSegment class methodsFor: 'instance creation'!yAxisUnit	^ self start: P3Point zero stop: (P3Point x: 0 y: 1) ! !!P3LineSegment class methodsFor: 'instance creation'!readFrom: stream	| start stop |	(stream peekFor: $[) ifFalse: [ 		(P3Error parsingFailed: 'opening [ not found') signal ].	start := P3Point readFrom: stream.	(stream peekFor: $,) ifFalse: [ 		(P3Error parsingFailed: 'separator , not found') signal ].	stop := P3Point readFrom: stream.	(stream peekFor: $]) ifFalse: [ 		(P3Error parsingFailed: 'closing ] not found') signal ].	^ self start: start stop: stop! !!P3LineSegment class methodsFor: 'instance creation'!start: start stop: stop	^ self new		start: start;		stop: stop;		yourself! !P3GeometricObject subclass: #P3Point	instanceVariableNames: 'x y'	classVariableNames: ''	package: 'P3-Objects'!!P3Point commentStamp: '' prior: 0!I am P3Point	(x,y)I am a P3GeometricObjectMy internal representation consists of my x and y coordinate!!P3Point methodsFor: 'printing'!printOn: stream	stream nextPut: $(.	x printOn: stream.	stream nextPut: $,.	y printOn: stream.	stream nextPut: $)! !!P3Point methodsFor: 'comparing'!= anotherPoint	self == anotherPoint ifTrue: [ ^ true ].	self class = anotherPoint class ifFalse: [ ^ false ].	^ x = anotherPoint x and: [ y = anotherPoint y ]! !!P3Point methodsFor: 'comparing'!hash	^ ( x hash hashMultiply + y hash) hashMultiply! !!P3Point methodsFor: 'private'!y: number	y := number! !!P3Point methodsFor: 'private'!x: number	x := number! !!P3Point methodsFor: 'accessing'!x	^ x! !!P3Point methodsFor: 'accessing'!y	^ y! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Point class	instanceVariableNames: ''!!P3Point class methodsFor: 'accessing'!tag	^ #point! !!P3Point class methodsFor: 'instance creation'!unit	^ self x: 1 y: 1! !!P3Point class methodsFor: 'instance creation'!readFrom: stream	| x y |	(stream peekFor: $() ifFalse: [ 		(P3Error parsingFailed: 'opening ( not found') signal ].	x := Number readFrom: stream.	(stream peekFor: $,) ifFalse: [ 		(P3Error parsingFailed: 'separator , not found') signal ].	y := Number readFrom: stream.	(stream peekFor: $)) ifFalse: [ 		(P3Error parsingFailed: 'closing ) not found') signal ].	^ self x: x y: y! !!P3Point class methodsFor: 'instance creation'!x: x y: y	^ self new		x: x;		y: y;		yourself! !!P3Point class methodsFor: 'instance creation'!zero	^ self x: 0 y: 0! !!P3Point class methodsFor: 'instance creation'!origin	^ self zero! !P3GeometricObject subclass: #P3Polygon	instanceVariableNames: 'points'	classVariableNames: ''	package: 'P3-Objects'!!P3Polygon commentStamp: '' prior: 0!I am P3Polygon	((x1,y1), ... ,(xn,yn))I am a P3GeometricObjectMy internal representation is an ordered collection of points!!P3Polygon methodsFor: 'printing'!printOn: stream	stream nextPut: $(.	self printPointsOn: stream.	stream nextPut: $)! !!P3Polygon methodsFor: 'printing'!printPointsOn: stream	points 		do: [ :each | each printOn: stream ] 		separatedBy: [ stream nextPut: $, ]! !!P3Polygon methodsFor: 'private'!points: collectionOfPoints	points := collectionOfPoints ! !!P3Polygon methodsFor: 'testing'!isClosed	^ true! !!P3Polygon methodsFor: 'testing'!isOpen	^ false! !!P3Polygon methodsFor: 'accessing'!numberOfPoints	^ points size! !!P3Polygon methodsFor: 'accessing'!points	^ points! !!P3Polygon methodsFor: 'comparing'!= anotherPolygon	self == anotherPolygon ifTrue: [ ^ true ].	self class = anotherPolygon class ifFalse: [ ^ false ].	^ points = anotherPolygon points! !!P3Polygon methodsFor: 'comparing'!hash	^ points hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Polygon class	instanceVariableNames: ''!!P3Polygon class methodsFor: 'accessing'!tag	^ #polygon! !!P3Polygon class methodsFor: 'instance creation'!points: aCollectionOfPoints	^ self new		points: aCollectionOfPoints asOrderedCollection;		yourself! !!P3Polygon class methodsFor: 'instance creation'!readFrom: stream	| points |	points := OrderedCollection new.	(stream peekFor: $() ifFalse: [ 		(P3Error parsingFailed: 'opening ( not found') signal ].	[ stream atEnd or: [ stream peek = $) ] ] whileFalse: [ | point |		point := P3Point readFrom: stream.		points add: point.		(stream atEnd or: [ stream peek = $) ] ) 			ifFalse: [ 				(stream peekFor: $,) ifFalse: [ 					(P3Error parsingFailed: 'separating , not found') signal ] ] ].	(stream peekFor: $)) ifFalse: [ 		(P3Error parsingFailed: 'closing ) not found') signal ].		^ self points: points! !P3Polygon subclass: #P3Path	instanceVariableNames: 'open'	classVariableNames: ''	package: 'P3-Objects'!!P3Path commentStamp: '' prior: 0!I am P3Path	[(x1,y1), ... ,(xn,yn)] open	((x1,y1), ... ,(xn,yn)) closedI am a P3Polygon and a P3GeometricObjectI inherit my representation and add the option to be open instead of closed!!P3Path methodsFor: 'testing'!isClosed	^ open not! !!P3Path methodsFor: 'testing'!isOpen	^ open! !!P3Path methodsFor: 'printing'!printOn: stream	stream nextPut: (self isOpen ifTrue: [ $[ ] ifFalse: [ $( ]).	self printPointsOn: stream.	stream nextPut: (self isOpen ifTrue: [ $] ] ifFalse: [ $) ])		! !!P3Path methodsFor: 'comparing'!= anotherPath	^ super = anotherPath and: [ open = anotherPath isOpen ]! !!P3Path methodsFor: 'comparing'!hash	^ super hash xor: open hash! !!P3Path methodsFor: 'initialization'!initialize	super initialize.	open := false! !!P3Path methodsFor: 'initialization'!beOpen	open := true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3Path class	instanceVariableNames: ''!!P3Path class methodsFor: 'accessing'!tag	^ #path! !!P3Path class methodsFor: 'instance creation'!openPoints: collectionOfPoints	^ (self points: collectionOfPoints)		beOpen;		yourself! !!P3Path class methodsFor: 'instance creation'!readFrom: stream	| points closer path |	points := OrderedCollection new.	closer := nil.	stream peek = $( ifTrue: [ closer := $) ].	stream peek = $[ ifTrue: [ closer := $] ].	closer 		ifNil: [ (P3Error parsingFailed: 'opening ( or [ not found') signal ] 		ifNotNil: [ stream next ]. 	[ stream atEnd or: [ stream peek = closer ] ] whileFalse: [ | point |		point := P3Point readFrom: stream.		points add: point.		(stream atEnd or: [ stream peek = closer ] ) 			ifFalse: [ 				(stream peekFor: $,) ifFalse: [ 					(P3Error parsingFailed: 'separating , not found') signal ] ] ].	(stream peekFor: closer) ifFalse: [ 		(P3Error parsingFailed: 'closing ) or ] not found') signal ].		path := self points: points.	closer = $] ifTrue: [ path beOpen ].	^ path! !Object subclass: #P3ValuesArray	instanceVariableNames: 'array'	classVariableNames: ''	package: 'P3-Objects'!!P3ValuesArray commentStamp: '' prior: 0!I am P3ValuesArray.I hold a list of database values that are rendered recursively as an array of values.I am a helper object used for statement construction.The following example shows a technique to use parameters for 'IN (...)' using '= ANY'.statement := client prepare: 'SELECT * FROM my_table WHERE id = ANY ($1)'.statement query: { P3ValuesArray withAll: #(1 2) }.statement := client format: 'SELECT * FROM fmi_owner WHERE id = ANY ($1)'.statement query: { P3ValuesArray withAll: #(1 2) }.!!P3ValuesArray methodsFor: 'testing'!isEmpty	^ array isNil or: [ array isEmpty ]! !!P3ValuesArray methodsFor: 'printing'!p3PrintUsing: delegate on: stream	"Print me on stream via double dispatch on delegate.	Check the implementors of #p3PrintOn:using:"	delegate printValuesArray: self on: stream! !!P3ValuesArray methodsFor: 'accessing'!values	^ array! !!P3ValuesArray methodsFor: 'accessing'!values: anArray	array := anArray! !!P3ValuesArray methodsFor: 'accessing'!size	^ array ifNil: [ 0 ] ifNotNil: [ array size ]! !!P3ValuesArray methodsFor: 'enumerating'!do: block	array do: block! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!P3ValuesArray class	instanceVariableNames: ''!!P3ValuesArray class methodsFor: 'instance creation'!withAll: collection	^ self new		values: collection asArray;		yourself! !